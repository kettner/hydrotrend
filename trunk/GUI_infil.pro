;   Idea:  Add "Slab" and "Slab Sequence" to the "type";          droplists for the Richards equation input variables.;*****************************************************************;   GUI_infil.pro;   Copyright (c) 2004-2008, Scott D. Peckham ;   Created:  March 2004;   Modified: July 2005 (improved Green-Ampt, plus Smith-Parlange);   Modified: Jan 2006  (impr. help messages, Richards equation);   Modified: Apr 2006  (more for Richards equation);   Modified: May 2006  (Richards equation, 3 layers);   Modified: Mar 2008  (GUI_Richards_Layer_Panel, >3 layers);*****************************************************************;-------------------------------------------;   For "closest standard soil type" parts;-------------------------------------------;   K_of_Theta;   Soil_Types        (function);   Get_Soil_Params   (function, 1/15/06);----------------------------------------------;   For Green-Ampt and Smith-Parlange methods;---------------------------------------------;   GUI_Infiltration_Vars_event;   GUI_Infiltration_Vars;----------------------------------------------------;   GUI for the 1D Richards' Equation method;----------------------------------------------------;   New method to collect layer properties  (3/5/08);----------------------------------------------------;   Read_Richards_Layer_Vars;   Richards_Layer_Vars_OK        (function);   GUI_Richards_Eqn_Vars_event;   GUI_Richards_Layer_Panel;   GUI_Richards_Eqn_Vars;----------------------------------------------;   GUI for choosing which infil vars to save;----------------------------------------------;   GUI_Save_Infil_Vars_event;   GUI_Save_Infil_Vars;---------------------------------------------------;   No longer used;  soon to be obsolete  (3/6/08);---------------------------------------------------;   GUI_Green_Ampt1_Formulas_event;   GUI_Green_Ampt1_Formulas;   GUI_Smith_Parlange_Formulas_event;   GUI_Smith_Parlange_Formulas;   GUI_Richards_Eqn_Formulas_event;   GUI_Richards_Eqn_Formulas;*****************************************************************function K_of_Theta, theta, K_s, theta_s, theta_r, lambda, $                     REPORT=REPORT;--------------------------------------------------------------;Notes:  This function returns the hydraulic conductivity, K,;        as a function of the soil moisture, theta, using an;        equation that holds for both the "Brooks-Corey" (B-C);        and "transitional Brooks-Corey" (TB-C) cases.;        Called by Get_Soil_Params to compute K_i.;        lambda = pore size distribution parameter;        eta    = "pore-disconnectedness" parameter;        eta    = 2d + (3d * lambda);        eps    = eta/lambda;        See "Infiltration Theory for Hydrologic Applica-;        tions" by R.E. Smith (2002), p. 19-22.;--------------------------------------------------------------REPORT = keyword_set(REPORT);--------------------------;Compute exponent, epsilon;--------------------------eta = (2d + (3d * lambda))eps = eta / lambda;------------------------------------;Compute the "relative conductivity";------------------------------------K_r = ((theta - theta_r) / (theta_s - theta_r))^eps;---------------------------;Compute K from K_s and K_r;---------------------------K_r = (K_r < 1d) > 0dK   = K_s * K_r;----------------;Optional report ;----------------if (REPORT) then begin    print,'K = ', K[0:3]    ;print,' 'endifRETURN, Kend;  K_of_Theta;*****************************************************************function Soil_Types, FORM2=FORM2if NOT(keyword_set(FORM2)) then begin    types = ['Sand', 'Loamy sand', 'Sandy loam', 'Silt loam', $             'Loam', 'Sandy clay loam', 'Silty clay loam', $             'Clay loam', 'Sandy clay', 'Silty clay', 'Clay']endif else begin    types = ['sand', 'loamy_sand', 'sandy_loam', 'silt_loam', $             'loam', 'sandy_clay_loam', 'silty_clay_loam', $             'clay_loam', 'sandy_clay', 'silty_clay', 'clay']endelseRETURN, typesend;  Soil_Types;*****************************************************************pro Get_Soil_Params, soil_type, por, K_s, psi_B, b, $                     lambda, eta, theta_s, G, $                     theta_i, K_i, theta_r, c, psi_A, $                     dz, nz, REPORT=REPORT;--------------------------------------------------------;Notes:  The values here are from Table 6.1 (p. 235) in;        Dingman (2002), 2nd. edition.  Data originally;        from Clapp and Hornberger (1978).;        Values for G were taken from Table 8.1 (p. 136);        in R.E. Smith's monograph.  Typical G for silt;        is given as 914.0 mm, but Dingman's table does;        not have an entry for silt. ;--------------------------------------------------------REPORT = keyword_set(REPORT)table = $[ [0.395,  1.76e-2,  12.1,  4.05, 82.0],   $   ;(sand)  [0.410,  1.56e-2,   9.0,  4.38, 97.0],   $   ;(loamy sand)  [0.435,  3.47e-3,  21.8,  4.90, 165.0],  $   ;(sandy loam)  [0.485,  7.20e-4,  78.6,  5.30, 724.0],  $   ;(silt loam)  [0.451,  6.95e-4,  47.8,  5.39, 385.0],  $   ;(loam)  [0.420,  6.30e-4,  29.9,  7.12, 240.0],  $   ;(sandy clay loam)  [0.477,  1.70e-4,  35.6,  7.75, 1590.0], $   ;(silty clay loam)  [0.476,  2.45e-4,  63.0,  8.52, 804.0],  $   ;(clay loam)  [0.426,  2.17e-4,  15.3,  10.4, 589.0],  $   ;(sandy clay)  [0.492,  1.03e-4,  49.0,  10.4, 3570.0], $   ;(silty clay)  [0.482,  1.28e-4,  40.5,  11.4, 2230.0] ]    ;(clay)types = Soil_Types(/FORM2)w = where(types eq strlowcase(soil_type), nw)if (nw eq 0) then begin    print,'*******************************'    print,' Sorry, soil type not found. '    print,'*******************************'    print,' '  &  RETURNendif;--------------------------;Get parameters from table;--------------------------row   = table[*, w[0]]por   = row[0]   ;[unitless]K_s   = row[1]   ;[cm/s]psi_B = row[2]   ;[cm]b     = row[3]   ;[unitless]G     = row[4]   ;[mm];--------------;Convert units;--------------K_s   = K_s   / 100d    ;([cm/s] -> [m/s])psi_B = psi_B / 100d    ;([cm]   -> [m])G     = G / 1000d       ;([mm]   -> [m]);----------------------------------;psi_B should be negative, right ?;----------------------------------psi_B = -1d * psi_B;----------------------;Computable parameters;----------------------lambda  = (1d / b)eta     = 2d + (3d * lambda)

;-------------------;Arbitrary defaults;-------------------c     = 1dpsi_A = 0d

;----------------------------------------
;Set saturated water content to porosity
;----------------------------------------theta_s = por    ;(generally a bit less)

;---------------------------------------------
;Set residual water content to Theta_Residual
;---------------------------------------------
theta_r = Theta_Residual(theta_s, psi_B, lambda)
;** theta_r = 0.05d    ;(before 3/18/08)

;--------------------------------------------
;Set initial water content to field capacity
;--------------------------------------------
theta_i = Theta_Field(theta_s, theta_r, psi_B, psi_A, c, lambda)
;** theta_i = 0.1d    ;(before 3/18/08)
;---------------------------------------;Set these values to ensure stability ?;NB!  Larger dz allows larger time step;---------------------------------------dz = 0.03d    ;(= 3 cm)nz = 20L;----------------------------------------;Compute K_i from theta_i, theta_r, etc.;----------------------------------------K_i = K_of_Theta(theta_i, K_s, theta_s, theta_r, lambda);----------------;Optional report;----------------if (REPORT) then begin
    print,'K_s      = ', K_s,      ' [m/s]'    print,'K_i      = ', K_i,      ' [m/s]'
    print,'porosity = ', por,      ' [unitless]'
    print,'theta_s  = ', theta_s,  ' [unitless]'    print,'theta_i  = ', theta_i,  ' [unitless]'
    print,'theta_r  = ', theta_r,  ' [unitless]'    print,'psi_B    = ', psi_B,    ' [m]'    print,'psi_a    = ', psi_a,    ' [m]'    print,'b        = ', b,        ' [unitless]'    print,'lambda   = ', lambda,   ' [unitless]'    print,'eta      = ', eta,      ' [unitless]'    print,'G        = ', G,        ' [m]'    print,' 'endifend;  Get_Soil_Params;*****************************************************************pro GUI_Infiltration_Vars_event, event;-----------;Error trap;-----------CATCH, statusTrace_Error, status, event, OKif NOT(OK) then RETURNGet_Event_Uvalue, event, uvalue, statetypes = Soil_Types(/FORM2)case (uvalue) of;****************'SOIL_TYPE' : $;****************beginstate.soil_type = types[event.index]Get_Soil_Params, state.soil_type, phi, Ks, pB, b, $                 lam, eta, qs, G, qi, Kiwidget_control, state.Ks_ID, set_value=TF_String(Ks)widget_control, state.Ki_ID, set_value=TF_String(Ki)widget_control, state.qs_ID, set_value=TF_String(qs)widget_control, state.qi_ID, set_value=TF_String(qi)widget_control, state.G_ID,  set_value=TF_String(G)end;****************;'RESET_ALL' : $;****************;begin;Get_Soil_Params, state.soil_type, phi, Ks, pB, b, $;                 lam, eta, qs, G, qi, Ki;widget_control, state.Ks_ID, set_value=TF_String(Ks);widget_control, state.Ki_ID, set_value=TF_String(Ki);widget_control, state.qs_ID, set_value=TF_String(qs);widget_control, state.qi_ID, set_value=TF_String(qi);widget_control, state.G_ID,  set_value=TF_String(G);------------------------------------------------------------;;widget_control, state.qr_ID,   set_value=TF_String(qr);;widget_control, state.infil_dt_ID, set_value= ?????;end;*********'OK' : $;*********begin;-------------------------------------------------------------Read_Input_Type, state.Ks_type, state.Ks_ID, Ks, $                 OK, filename=Ks_fileif NOT(OK) then RETURN;-------------------------------------------------------------Read_Input_Type, state.Ki_type, state.Ki_ID, Ki, $                 OK, filename=Ki_fileif NOT(OK) then RETURN;-------------------------------------------------------------Read_Input_Type, state.qs_type, state.qs_ID, qs, $                 OK, filename=qs_fileif NOT(OK) then RETURN;-------------------------------------------------------------Read_Input_Type, state.qi_type, state.qi_ID, qi, $                 OK, filename=qi_fileif NOT(OK) then RETURN;-------------------------------------------------------------Read_Input_Type, state.G_type, state.G_ID, G, $                 OK, filename=G_fileif NOT(OK) then RETURN;-------------------------------------------------------------if (state.gamma_model) then begin    Read_Input_Type, state.gam_type, state.gam_ID, gam, $                     OK, filename=gam_file    if NOT(OK) then RETURNendif else gam=0.0;-------------------------------------------------------------Read_Text_Box, state.infil_dt_ID, infil_dt, OK, /DOUBLEif NOT(OK) then RETURN;--------------------------;Check the input variables;--------------------------if (state.Ks_type eq 0b) AND $   (state.Ki_type eq 0b) AND $   ((Ks le Ki) OR (Ki lt 0.0) OR (Ks lt 0.0)) then begin    msg = [ $    'Input Error:', ' ',$    'Ki must be less than Ks and both',$    'values must be nonnegative.', ' ']    result = GUI_Message(msg, /INFO)    RETURNendif;--------------------------------------------------if (state.qs_type eq 0b) AND $   (state.qi_type eq 0b) AND (qs le qi) then begin    msg = [ $    'Input Error: ', ' ',$    'theta_i must be less than theta_s.', ' ']    result = GUI_Message(msg, /INFO)    RETURNendif;--------------------------------------------------if (state.qs_type eq 0b) AND $   ((qs gt 1.0) OR (qs lt 0.0)) then begin    msg = [ $    'Input Error:', ' ',$    'theta_s must be between 0 and 1 and must', $    'be less than the soil porosity.', ' ']    result = GUI_Message(msg, /INFO)    RETURNendif;--------------------------------------------------if (state.qi_type eq 0b) AND $   ((qi gt 1.0) OR (qi lt 0.0)) then begin    msg = [ $    'Input Error:', ' ',$    'theta_i must be between 0 and 1 and must', $    'be greater than the residual value.', ' ']    result = GUI_Message(msg, /INFO)    RETURNendif;--------------------------------------------------if (state.G_type eq 0b) AND (G lt 0.0) then begin    msg = [ $    'Input Error:', ' ',$    'G must be greater than zero.', ' ']    result = GUI_Message(msg, /INFO)    RETURNendif;-------------------------------------------------------if (state.gamma_model) AND (state.gam_type eq 0b) AND $   ((gam lt 0.0) OR (gam gt 1.0)) then begin    msg = [ $    'Input Error:', ' ',$    'Gamma must be between 0 and 1, inclusive,', $    'and is typically between 0.8 and 0.85.', ' ']    result = GUI_Message(msg, /INFO)    RETURNendif;------------------------------------------------;Check the timestep (min_duration is in minutes);------------------------------------------------if ((infil_dt / 60d) gt state.min_duration) then begin    msg = [ $    'WARNING:  Infiltration timestep exceeds the minimum ', $    '          rainfall duration, which may cause errors. ', $    ' ',$    'Do you want the timestep to be changed to the minimum ',$    'rainfall duration? ',$    ' ']    answer = GUI_Message(msg, /QUESTION)    if (answer eq 'Yes') then begin        tstr = TF_String(state.min_duration * 60d)        widget_control, state.infil_dt_ID, set_value=tstr        RETURN    endifendif;------------------------;Upload values to leader;------------------------Get_TLB_State, state.leader_ID, mstate, ALIVEif NOT(ALIVE) then RETURN;--------------------------------------*mstate.infil_vars.Ks      = Ks*mstate.infil_vars.Ki      = Ki*mstate.infil_vars.qs      = qs*mstate.infil_vars.qi      = qi*mstate.infil_vars.G       = G;--------------------------------------mstate.infil_vars.Ks_file[0]  = Ks_file
mstate.infil_vars.Ki_file[0]  = Ki_filemstate.infil_vars.qs_file[0]  = qs_filemstate.infil_vars.qi_file[0]  = qi_filemstate.infil_vars.G_file      = G_file;--------------------------------------------mstate.infil_vars.Ks_type[0]  = state.Ks_typemstate.infil_vars.Ki_type[0]  = state.Ki_typemstate.infil_vars.qs_type[0]  = state.qs_typemstate.infil_vars.qi_type[0]  = state.qi_typemstate.infil_vars.G_type      = state.G_type;--------------------------------------------if (state.gamma_model) then begin    *mstate.infil_vars.gam = gam    mstate.infil_vars.gam_file = gam_file    mstate.infil_vars.gam_type = state.gam_typeendif;-------------------------------------------------------mstate.infil_vars.soil_type[0] = state.soil_typemstate.infil_vars.dt  = infil_dt  ;[seconds; see above];-------------------------------------------------------widget_control, state.leader_ID, set_uvalue=mstateClose_Dialog, event.top end;***********************************;Set data types for soil variables;***********************************'KS_TYPE'  : state.Ks_type  = event.index'KI_TYPE'  : state.Ki_type  = event.index'QS_TYPE'  : state.qs_type  = event.index'QI_TYPE'  : state.qi_type  = event.index'G_TYPE'   : state.G_type   = event.index'GAM_TYPE' : state.gam_type = event.index;***********'HELP' : $;***********if (state.gamma_model) then begin    Show_HTML_Help, 'infil_Smith-Parlange.htm'endif else begin    Show_HTML_Help, 'infil_Green-Ampt.htm'endelse;************'CANCEL' : $;************Close_Dialog, event.topELSE : dum=0endcaseif (uvalue ne 'CANCEL') AND $   (uvalue ne 'OK') then $    widget_control, event.top, set_uvalue=state END;  GUI_Infiltration_Vars_event;*****************************************************************pro GUI_Infiltration_Vars, leader, GAMMA=GAMMA;-----------;Error trap;-----------No_Catch, statusCheck_Error_Status, status, OKif NOT(OK) then RETURNFORWARD_FUNCTION Var_SettingGAMMA = keyword_set(GAMMA)if (n_elements(leader) eq 0) then leader=0L ;-----------------------------------;Get current values from main state;-----------------------------------Get_TLB_State, leader, mstate, ALIVEif NOT(ALIVE) then RETURN;------------------------------------------------------Ks_str  = Var_Setting(mstate.infil_vars.Ks_type[0], $                      mstate.infil_vars.Ks, $                      mstate.infil_vars.Ks_file[0])Ki_str  = Var_Setting(mstate.infil_vars.Ki_type[0], $                      mstate.infil_vars.Ki, $                      mstate.infil_vars.Ki_file[0])qs_str  = Var_Setting(mstate.infil_vars.qs_type[0], $                      mstate.infil_vars.qs, $                      mstate.infil_vars.qs_file[0])qi_str  = Var_Setting(mstate.infil_vars.qi_type[0], $                      mstate.infil_vars.qi, $                      mstate.infil_vars.qi_file[0]);------------------------------------------------------G_str   = Var_Setting(mstate.infil_vars.G_type, $                      mstate.infil_vars.G, $                      mstate.infil_vars.G_file)gam_str = Var_Setting(mstate.infil_vars.gam_type, $                      mstate.infil_vars.gam, $                      mstate.infil_vars.gam_file);-----------------------------;Get default/current timestep;-----------------------------dt_i = mstate.infil_vars.dt    ;[sec]tstr = TF_String(dt_i);------------------------------;Store the min precip duration;for possible warning to user;------------------------------durs = *mstate.precip_vars.durationswd   = where(durs gt 0, nw)if (nw gt 0) then begin    dt_p = min(durs[wd])  ;[in minutes]endif else dt_p = dt_i;------------------------------------------;Store selected options in state structure;------------------------------------------state = { $leader_ID:leader, $Ks_ID:0L,    Ks_type:  mstate.infil_vars.Ks_type[0], $Ki_ID:0L,    Ki_type:  mstate.infil_vars.Ki_type[0], $qs_ID:0L,    qs_type:  mstate.infil_vars.qs_type[0], $qi_ID:0L,    qi_type:  mstate.infil_vars.qi_type[0], $G_ID:0L,     G_type:   mstate.infil_vars.G_type,     $gam_ID:0L,   gam_type: mstate.infil_vars.gam_type,   $gamma_model: GAMMA, $soil_type: mstate.infil_vars.soil_type[0], $infil_dt_ID:0L, min_duration:dt_p}ngap  = 6fsize = 20XS    = 44types = Model_Input_Types()if (GAMMA) then begin    title = 'Infiltration Variables: Smith-Parlange 3-param.'endif else begin    title = 'Infiltration Variables: Green-Ampt'endelse;-----------------;Main base widget;-----------------Create_TLB, MB, TITLE=title, /COLUMN, LEADER=leaderB = widget_base(MB, /COLUMN, /FRAME);-------------------;Get the parameters;-------------------A1 = widget_base(B, /ROW, SPACE=ngap)  A11 = widget_label(A1, VALUE='Variable: ', UVALUE='NONE')  A12 = widget_label(A1, VALUE='Type: ', UVALUE='NONE')  A13 = widget_label(A1, VALUE='Scalar or Grid Filename: ', UVALUE='NONE')  A14 = widget_label(A1, VALUE='Units: ', UVALUE='NONE');--------------------------------------------------------------------------KS = widget_base(B, /ROW, SPACE=ngap)  KS1 = widget_label(KS, VALUE='K_s: ')  KS2 = widget_droplist(KS, VALUE=types, UVALUE='KS_TYPE')  KS3 = widget_text(KS, VALUE=Ks_str, UVALUE='NONE', /EDITABLE, XSIZE=8)  KS4 = widget_label(KS, VALUE='[m/s]')  state.Ks_ID = KS3  widget_control, KS2, set_droplist_select=mstate.infil_vars.Ks_type[0];--------------------------------------------------------------------------KI = widget_base(B, /ROW, SPACE=ngap)  KI1 = widget_label(KI, VALUE='K_i: ')  KI2 = widget_droplist(KI, VALUE=types, UVALUE='KI_TYPE')  KI3 = widget_text(KI, VALUE=Ki_str, UVALUE='NONE', /EDITABLE, XSIZE=fsize)  KI4 = widget_label(KI, VALUE='[m/s]')  state.Ki_ID   = KI3  widget_control, KI2, set_droplist_select=mstate.infil_vars.Ki_type[0] ;--------------------------------------------------------------------------QS = widget_base(B, /ROW, SPACE=ngap)  QS1 = widget_label(QS, VALUE='theta_s: ', UVALUE='NONE')  QS2 = widget_droplist(QS, VALUE=types, UVALUE='QS_TYPE')  QS3 = widget_text(QS, VALUE=qs_str, UVALUE='NONE', $                    /EDITABLE, XSIZE=fsize)  QS4 = widget_label(QS, VALUE='[unitless]', UVALUE='NONE')  state.qs_ID = QS3  widget_control, QS2, set_droplist_select=mstate.infil_vars.qs_type[0] ;--------------------------------------------------------------------------QI = widget_base(B, /ROW, SPACE=ngap)  QI1 = widget_label(QI, VALUE='theta_i: ', UVALUE='NONE')  QI2 = widget_droplist(QI, VALUE=types, UVALUE='QI_TYPE')  QI3 = widget_text(QI, VALUE=qi_str, UVALUE='NONE', $                    /EDITABLE, XSIZE=fsize)  QI4 = widget_label(QI, VALUE='[unitless]', UVALUE='NONE')  state.qi_ID = QI3  widget_control, QI2, set_droplist_select=mstate.infil_vars.qi_type[0] ;--------------------------------------------------------------------------GG = widget_base(B, /ROW, SPACE=ngap)  GG1 = widget_label(GG, VALUE='G: ')  GG2 = widget_droplist(GG, VALUE=types, UVALUE='G_TYPE')  GG3 = widget_text(GG, VALUE=G_str, UVALUE='NONE', /EDITABLE, XSIZE=fsize)  GG4 = widget_label(GG, VALUE='[meters]')  state.G_ID = GG3  widget_control, GG2, set_droplist_select=mstate.infil_vars.G_type ;-------------------------------------------------------------------------if (GAMMA) then begin    GA = widget_base(B, /ROW, SPACE=ngap)      GA1 = widget_label(GA, VALUE='gamma: ')      GA2 = widget_droplist(GA, VALUE=types, UVALUE='GAM_TYPE')      GA3 = widget_text(GA, VALUE=gam_str, UVALUE='NONE', $                        /EDITABLE, XSIZE=fsize)      GA4 = widget_label(GA, VALUE='[unitless]')      state.gam_ID = GA3      widget_control, GA2, set_droplist_select=mstate.infil_vars.gam_typeendifBZ = widget_label(B, VALUE=' ');---------------------------------------------;Droplist to set params for a given soil type;---------------------------------------------ST = widget_base(B, /ROW, SPACE=ngap)  ST1 = widget_label(ST, VALUE='Closest standard soil type: ')  types  = Soil_Types()  types  = Str_Pad(types, 1)  types2 = Soil_Types(/FORM2)  wt  = where(types2 eq mstate.infil_vars.soil_type[0], nw)  ST2 = widget_droplist(ST, VALUE=types, UVALUE='SOIL_TYPE')  widget_control, ST2, set_droplist_select=wt[0]  ;----------------------------------------------------------------  ;** ST3 = widget_label(ST, VALUE=' ')  ;** ST4 = widget_button(ST, VALUE=' Reset All ', UVALUE='RESET_ALL');------------------------------;Infiltration process timestep;------------------------------TI = widget_base(B, /ROW, SPACE=ngap)  TI1 = widget_label(TI, VALUE='Infiltration process timestep: ', UVALUE='NONE')  TI2 = widget_text(TI, VALUE=tstr, UVALUE='NONE', /EDITABLE, XSIZE=10)  TI3 = widget_label(TI, VALUE='[seconds / timestep]', UVALUE='NONE')  state.infil_dt_ID = TI2L1 = widget_label(B, VALUE=' ', UVALUE='NONE')L2 = widget_label(B, UVALUE='NONE', /ALIGN_LEFT, $            VALUE='Note: Timestep must not exceed min precip duration.')Align_Text_Boxes, [ST1, TI1]Align_Text_Boxes, [ST2, TI2];------------------;Align the widgets;------------------if (GAMMA) then begin    Align_Text_Boxes, [A11, KS1, KI1, QS1, QI1, GG1, GA1]    Align_Text_Boxes, [A12, KS2, KI2, QS2, QI2, GG2, GA2]    Align_Text_Boxes, [A13, KS3, KI3, QS3, QI3, GG3, GA3]endif else begin    Align_Text_Boxes, [A11, KS1, KI1, QS1, QI1, GG1]    Align_Text_Boxes, [A12, KS2, KI2, QS2, QI2, GG2]    Align_Text_Boxes, [A13, KS3, KI3, QS3, QI3, GG3]endelse;------------------;Bottom button bar;------------------CW_Button_Bar, MB, /OK, /HELP, /CANCEL;------------------------------------;Realize widgets and wait for events ;------------------------------------Realize_TLB, MB, state, 'GUI_Infiltration_Vars', XOFF=480, TW=TWEND;  GUI_Infiltration_Vars;*****************************************************************pro Read_Richards_Layer_Vars, state, Ks, Ks_file, Ki, Ki_file, $         qs, qs_file, qi, qi_file, qr, qr_file, $         pB, pB_file, pA, pA_file, $         lam, lam_file, c, c_file, dz, nz, OKOK = 1b;-------------------------------;Initialize the soil var arrays;-------------------------------Ks  = dblarr(state.n_layers)Ki  = dblarr(state.n_layers)qs  = dblarr(state.n_layers)qi  = dblarr(state.n_layers)qr  = dblarr(state.n_layers)pB  = dblarr(state.n_layers)pA  = dblarr(state.n_layers)lam = dblarr(state.n_layers)c   = dblarr(state.n_layers);--------------------------------dz  = dblarr(state.n_layers)nz  = intarr(state.n_layers);--------------------------------Ks_file  = strarr(state.n_layers)Ki_file  = strarr(state.n_layers)qs_file  = strarr(state.n_layers)qi_file  = strarr(state.n_layers)qr_file  = strarr(state.n_layers)pB_file  = strarr(state.n_layers)pA_file  = strarr(state.n_layers)lam_file = strarr(state.n_layers)c_file   = strarr(state.n_layers);----------------------------------------;Read the soil properties for all layers;----------------------------------------for j=0,(state.n_layers-1) do begin    Read_Input_Type, state.Ks_type[j], state.Ks_ID[j], Ksj, $                 OK, filename=Ks_file_j    if NOT(OK) then RETURN    Ks[j]      = Ksj    Ks_file[j] = Ks_file_j    ;----------------------------------------------------------    Read_Input_Type, state.Ki_type[j], state.Ki_ID[j], Kij, $                 OK, filename=Ki_file_j    if NOT(OK) then RETURN    Ki[j]      = Kij    Ki_file[j] = Ki_file_j    ;----------------------------------------------------------    Read_Input_Type, state.qs_type[j], state.qs_ID[j], qsj, $                 OK, filename=qs_file_j    if NOT(OK) then RETURN    qs[j]      = qsj    qs_file[j] = qs_file_j    ;----------------------------------------------------------    Read_Input_Type, state.qi_type[j], state.qi_ID[j], qij, $                 OK, filename=qi_file_j    if NOT(OK) then RETURN    qi[j]      = qij    qi_file[j] = qi_file_j    ;----------------------------------------------------------    Read_Input_Type, state.qr_type[j], state.qr_ID[j], qrj, $                 OK, filename=qr_file_j    if NOT(OK) then RETURN    qr[j]      = qrj    qr_file[j] = qr_file_j    ;----------------------------------------------------------    Read_Input_Type, state.pB_type[j], state.pB_ID[j], pBj, $                 OK, filename=pB_file_j    if NOT(OK) then RETURN    pB[j]      = pBj    pB_file[j] = pB_file_j    ;----------------------------------------------------------    Read_Input_Type, state.pA_type[j], state.pA_ID[j], pAj, $                 OK, filename=pA_file_j    if NOT(OK) then RETURN    pA[j]      = pAj    pA_file[j] = pA_file_j    ;----------------------------------------------------------    Read_Input_Type, state.lam_type[j], state.lam_ID[j], lamj, $                 OK, filename=lam_file_j    if NOT(OK) then RETURN    lam[j]      = lamj    lam_file[j] = lam_file_j    ;----------------------------------------------------------    Read_Input_Type, state.c_type[j], state.c_ID[j], cj, $                 OK, filename=c_file_j    if NOT(OK) then RETURN    c[j]      = cj    c_file[j] = c_file_j    ;--------------------------------    ;Read dz and nz from text boxes    ;--------------------------------    Read_Text_Box, state.dz_ID[j], dzj, OK, /DOUBLE    if NOT(OK) then RETURN    dz[j] = dzj    ;----------------------------------------------    Read_Text_Box, state.nz_ID[j], nzj, OK, /INTEGER    if NOT(OK) then RETURN    nz[j] = nzjendforend;  Read_Richards_Layer_Vars;*****************************************************************function Richards_Layer_Vars_OK, state, Ks, Ks_file, Ki, Ki_file, $                  qs, qs_file, qi, qi_file, qr, qr_file, $                  pB, pB_file, pA, pA_file, $                  lam, lam_file, c, c_file, dz, nz;-------------------------------------------------------;NB!  These comparisons work because the returned vars;     will be scalars even if the type is not scalar.;     (state is passed as state.L1, etc.);-------------------------------------------------------;----------------------------------------;Check the soil properties for all layers;----------------------------------------for j=0,(state.n_layers-1) do begin    heading = 'Input Error in Layer' + TF_String(j+1) + ':'    ;---------------------------------------------------------    if (state.Ks_type[j] eq 0b) AND $       (state.Ki_type[j] eq 0b) AND $       ((Ks[j] le Ki[j]) OR (Ki[j] lt 0.0) OR (Ks[j] lt 0.0)) then begin        msg = [ $        heading, ' ',$        'Ki must be less than Ks and both',$        'values must be nonnegative.', ' ']        result = GUI_Message(msg, /INFO)        RETURN, 0b    endif    ;--------------------------------------------------    ;print,'state.qs_type[j] = ', state.qs_type[j]    ;print,'state.qi_type[j] = ', state.qi_type[j]    ;print,'state.qr_type[j] = ', state.qr_type[j]    if (state.qs_type[j] eq 0b) AND $
       (state.qi_type[j] eq 0b) AND $       (state.qr_type[j] eq 0b) AND $       ((qi[j] le qr[j]) OR (qi[j] gt qs[j])) then begin    ;(qi=qs is allowed)        msg = [ $        heading, ' ',$        'theta_i must be less than theta_s and', $        'greater than residual value, theta_r.', ' ']        result = GUI_Message(msg, /INFO)        RETURN, 0b    endif    ;--------------------------------------------------    if (state.qs_type[j] eq 0b) AND $       ((qs[j] gt 1.0) OR (qs[j] lt 0.0)) then begin        msg = [ $        heading, ' ',$        'theta_s must be between 0 and 1 and must', $        'be less than the soil porosity.', ' ']        result = GUI_Message(msg, /INFO)        RETURN, 0b    endif    ;--------------------------------------------------    if (state.qi_type[j] eq 0b) AND $       ((qi[j] gt 1.0) OR (qi[j] lt 0.0)) then begin        msg = [ $        heading, ' ',$        'theta_i must be between 0 and 1 and must', $        'be greater than the residual value.', ' ']        result = GUI_Message(msg, /INFO)        RETURN, 0b    endif    ;--------------------------------------------------    if (state.qr_type[j] eq 0b) AND $       ((qr[j] gt 1.0) OR (qr[j] lt 0.0)) then begin        msg = [ $        heading, ' ',$        'theta_r must be between 0 and 1 and must', $        'be less than the initial value.', ' ']        result = GUI_Message(msg, /INFO)        RETURN, 0b    endif    ;-----------------------------------------------------    if (state.pB_type[j] eq 0b) AND (pB[j] gt 0) then begin        msg = [ $        heading, ' ',$        'psi_B must be less than or equal to zero.', ' ']        result = GUI_Message(msg, /INFO)        RETURN, 0b    endif    ;-----------------------------------------------------    ;It seems that psi_A can be positive    ;------------------------------------    ;if (state.pA_type[j] eq 0b) AND (pA[j] gt 0) then begin    ;    msg = [ $    ;    heading, ' ',$    ;    'psi_A must be less than or equal to zero.', ' ']    ;    result = GUI_Message(msg, /INFO)    ;    RETURN, 0b    ;endif    ;-----------------------------------------------------    if (state.c_type[j] eq 0b) AND (c[j] lt 0.0) then begin        msg = [ $        heading, ' ',$        'c must be greater than zero.', ' ']        result = GUI_Message(msg, /INFO)        RETURN, 0b    endif    ;-------------------------------------------------------    if (state.lam_type[j] eq 0b) AND $       ((lam[j] lt 0.0) OR (lam[j] gt 1.0)) then begin        msg = [ $        heading, ' ',$        'Lambda must be between 0 and 1, and is', $        'typically between 0.15 and 0.65.', ' ']        result = GUI_Message(msg, /INFO)        RETURN, 0b    endif    ;-----------------------------------------------------    if ((nz[j] lt 10) OR (nz[j] gt 100)) then begin        msg = [ $        heading, ' ',$        'Number of subsurface nodes must be greater than ', $        '10 and less than internal limit of 100.', ' ']        result = GUI_Message(msg, /INFO)        RETURN, 0b    endifendfor;--------------------------;Everything seems to be OK;--------------------------RETURN, 1bend;  Richards_Layer_Vars_OK;*****************************************************************pro GUI_Richards_Eqn_Vars_event, event;----------------------------------------------------------------;Notes:  3/11/08.  New approach to reduce the amount of code;        and simplify event handling for multiple soil layers.;        Added a "visible_panel" variable to the state that;        allows each panel to use the same "uvalues" for events.;        Related changes made to GUI_Richards_Layer_Panel.;----------------------------------------------------------------;-----------;Error trap;-----------CATCH, statusTrace_Error, status, event, OKif NOT(OK) then RETURNGet_Event_Uvalue, event, uvalue, statetypes = Soil_Types(/FORM2)PANEL_CHANGE = 0b             ;(default)n = state.visible_panelcase (uvalue) of;***********'NEXT' : $;***********beginPANEL_CHANGE = 1bstate.visible_panel = n + 1end;***********'BACK' : $;***********beginPANEL_CHANGE = 1bstate.visible_panel = n - 1end;***************************;SOIL LAYER VAR DATA TYPES;***************************'KS_TYPE'  : state.Ks_type[n]  = event.index'KI_TYPE'  : state.Ki_type[n]  = event.index'QS_TYPE'  : state.qs_type[n]  = event.index'QI_TYPE'  : state.qi_type[n]  = event.index'QR_TYPE'  : state.qr_type[n]  = event.index'PB_TYPE'  : state.pB_type[n]  = event.index'PA_TYPE'  : state.pA_type[n]  = event.index'C_TYPE'   : state.c_type[n]   = event.index'LAM_TYPE' : state.lam_type[n] = event.index
;-------------------------------------
;These aren't needed;  always scalars
;-------------------------------------;'DZ_TYPE' : state.dz_type[n]  = event.index;'NZ_TYPE' : state.nz_type[n]  = event.index

;****************'SOIL_TYPE' : $;****************beginstate.soil_type[n] = types[event.index]Get_Soil_Params, state.soil_type[n], phi, Ks, pB, b, $                 lam, eta, qs, G, $                 qi, Ki, qr, c, pA, dz, nz   ;(arbitrary)widget_control, state.Ks_ID[n],  set_value=TF_String(Ks)widget_control, state.Ki_ID[n],  set_value=TF_String(Ki)widget_control, state.qs_ID[n],  set_value=TF_String(qs)widget_control, state.qi_ID[n],  set_value=TF_String(qi)widget_control, state.qr_ID[n],  set_value=TF_String(qr)widget_control, state.pB_ID[n],  set_value=TF_String(pB)widget_control, state.pA_ID[n],  set_value=TF_String(pA)widget_control, state.c_ID[n],   set_value=TF_String(c)widget_control, state.lam_ID[n], set_value=TF_String(lam)widget_control, state.dz_ID[n],  set_value=TF_String(dz)widget_control, state.nz_ID[n],  set_value=TF_String(nz)end
;*********'OK' : $;*********begin;------------------------------------------;Read all soil layer variables into arrays;------------------------------------------Read_Richards_Layer_Vars, state, Ks, Ks_file, Ki, Ki_file, $                          qs, qs_file, qi, qi_file, qr, qr_file, $                          pB, pB_file, pA, pA_file, $                          lam, lam_file, c, c_file, dz, nz;-----------------------------------;Check all the soil layer variables;-----------------------------------OK = Richards_Layer_Vars_OK(state, Ks, Ks_file, Ki, Ki_file, $                            qs, qs_file, qi, qi_file, qr, qr_file, $                            pB, pB_file, pA, pA_file, $                            lam, lam_file, c, c_file, dz, nz )if NOT(OK) then RETURN;----------------------------------;NB!  Units of infil_dt is seconds;----------------------------------Read_Text_Box, state.infil_dt_ID, infil_dt, OK, /DOUBLEif NOT(OK) then RETURN;------------------------------------------------;Check the timestep (min_duration is in minutes);------------------------------------------------if ((infil_dt / 60d) gt state.min_duration) then begin    msg = [ $    'WARNING:  Infiltration timestep exceeds the minimum ', $    '          rainfall duration, which may cause errors. ', $    ' ',$    'Do you want the timestep to be changed to the minimum ',$    'rainfall duration? ',$    ' ']    answer = GUI_Message(msg, /QUESTION)    if (answer eq 'Yes') then begin        tstr = TF_String(state.min_duration * 60d)        widget_control, state.infil_dt_ID, set_value=tstr        RETURN    endifendif;------------------------;Upload values to leader;------------------------Get_TLB_State, state.leader_ID, mstate, ALIVEif NOT(ALIVE) then RETURN;-------------------------------mstate.infil_vars.dt = infil_dt;----------------------------------;Upload values for all soil layers;----------------------------------for j=0,(state.n_layers-1) do begin    *mstate.infil_vars.Ks_val[j]   = Ks[j]    *mstate.infil_vars.Ki_val[j]   = Ki[j]    *mstate.infil_vars.qs_val[j]   = qs[j]    *mstate.infil_vars.qi_val[j]   = qi[j]    *mstate.infil_vars.qr_val[j]   = qr[j]    *mstate.infil_vars.pB_val[j]   = pB[j]    *mstate.infil_vars.pA_val[j]   = pA[j]    *mstate.infil_vars.lam_val[j]  = lam[j]    *mstate.infil_vars.c_val[j]    = c[j]    ;---------------------------------------------    mstate.infil_vars.dz_val[j] = dz[j]    mstate.infil_vars.nz_val[j] = nz[j]    mstate.infil_vars.soil_type[j] = state.soil_type[j]     ;----------------------------------------------------    mstate.infil_vars.Ks_file[j]   = Ks_file[j]    mstate.infil_vars.Ki_file[j]   = Ki_file[j]    mstate.infil_vars.qs_file[j]   = qs_file[j]
    mstate.infil_vars.qi_file[j]   = qi_file[j]    mstate.infil_vars.qr_file[j]   = qr_file[j]    mstate.infil_vars.pB_file[j]   = pB_file[j]    mstate.infil_vars.pA_file[j]   = pA_file[j]    mstate.infil_vars.lam_file[j]  = lam_file[j]    mstate.infil_vars.c_file[j]    = c_file[j]    ;-------------------------------------------------    mstate.infil_vars.Ks_type[j]   = state.Ks_type[j]    mstate.infil_vars.Ki_type[j]   = state.Ki_type[j]    mstate.infil_vars.qs_type[j]   = state.qs_type[j]    mstate.infil_vars.qi_type[j]   = state.qi_type[j]    mstate.infil_vars.qr_type[j]   = state.qr_type[j]    mstate.infil_vars.pB_type[j]   = state.pB_type[j]    mstate.infil_vars.pA_type[j]   = state.pA_type[j]    mstate.infil_vars.lam_type[j]  = state.lam_type[j]    mstate.infil_vars.c_type[j]    = state.c_type[j]endfor;---------------------------------------------------widget_control, state.leader_ID, set_uvalue=mstateClose_Dialog, event.top end;***********'HELP' : $;***********Show_HTML_Help, 'infil_Richards.htm';************'CANCEL' : $;************Close_Dialog, event.topELSE : dum=0endcase;--------------------------------;Change to a new panel  (remap);--------------------------------if (PANEL_CHANGE) then begin    onoff = bytarr(state.n_layers)    onoff[state.visible_panel] = 1b    for k=0,(state.n_layers-1) do begin        widget_control, state.bases[k], MAP=onoff[k]    endforendifif (uvalue ne 'CANCEL') AND $   (uvalue ne 'OK') then $    widget_control, event.top, set_uvalue=state END;  GUI_Richards_Eqn_Vars_event;*****************************************************************function GUI_Richards_Layer_Panel, PARENT, state, mstate, j;-----------------------------------------------------------;Notes:  Written on 3/6/08, based on GUI_Darcy_Layer_Panel;        in GUI_gw.pro;-----------------------------------------------------------FORWARD_FUNCTION Var_Settingngap  = 6fsize = 20XS    = 44types = Model_Input_Types()jstr  = strtrim(string(j+1), 2);-----------------------------------------------------------;(3/13/08) In order to get the last 2 droplists that have;only the Scalar option to have the same screen width as;the other droplists (under X11, e.g. Mac OS X), we need;to make the lists themselves have the same width.;-----------------------------------------------------------len = max(strlen(types))stype = Str_Resize('Scalar ', len)   ;(Need 1 space on RHS!);------------------------------------------;Get values from main state for this layer;------------------------------------------Ks_str   = Var_Setting(mstate.infil_vars.Ks_type[j], $                       mstate.infil_vars.Ks_val[j], $                       mstate.infil_vars.Ks_file[j])Ki_str   = Var_Setting(mstate.infil_vars.Ki_type[j], $                       mstate.infil_vars.Ki_val[j], $                       mstate.infil_vars.Ki_file[j])qs_str   = Var_Setting(mstate.infil_vars.qs_type[j], $                       mstate.infil_vars.qs_val[j], $                       mstate.infil_vars.qs_file[j])qi_str   = Var_Setting(mstate.infil_vars.qi_type[j], $                       mstate.infil_vars.qi_val[j], $                       mstate.infil_vars.qi_file[j])qr_str   = Var_Setting(mstate.infil_vars.qr_type[j], $                       mstate.infil_vars.qr_val[j], $                       mstate.infil_vars.qr_file[j])pB_str   = Var_Setting(mstate.infil_vars.pB_type[j], $                       mstate.infil_vars.pB_val[j], $                       mstate.infil_vars.pB_file[j])pA_str   = Var_Setting(mstate.infil_vars.pA_type[j], $                       mstate.infil_vars.pA_val[j], $                       mstate.infil_vars.pA_file[j])lam_str  = Var_Setting(mstate.infil_vars.lam_type[j], $                       mstate.infil_vars.lam_val[j], $                       mstate.infil_vars.lam_file[j])c_str    = Var_Setting(mstate.infil_vars.c_type[j], $                       mstate.infil_vars.c_val[j], $                       mstate.infil_vars.c_file[j]);-----------------------------;Get scalar values, dz and nz;-----------------------------dz_str = TF_String(mstate.infil_vars.dz_val[j])    ;[meters]nz_str = TF_String(mstate.infil_vars.nz_val[j]);--------------------------;Create the top-level base;and two "middle bases";--------------------------MB = widget_base(PARENT, /COLUMN)TB = widget_base(MB, /COLUMN)CB = widget_base(MB, /COLUMN, /FRAME);-------------------------;Use top base for heading;-------------------------v0 = 'Variables for Soil Layer ' + jstr + ':'L0 = widget_label(TB, VALUE=v0, /ALIGN_LEFT);-------------------------;Get vars for this layer;-------------------------A1 = widget_base(CB, /ROW, SPACE=ngap)  A11 = widget_label(A1, VALUE='Variable: ')  A12 = widget_label(A1, VALUE='Type: ')  A13 = widget_label(A1, VALUE='Scalar or Grid Filename: ')  A14 = widget_label(A1, VALUE='Units: ');--------------------------------------------------------------------------KS = widget_base(CB, /ROW, SPACE=ngap)  KS1 = widget_label(KS, VALUE='K_s: ')  KS2 = widget_droplist(KS, VALUE=types, UVALUE='KS_TYPE')  KS3 = widget_text(KS, VALUE=Ks_str, UVALUE='NONE', /EDITABLE, XSIZE=8)  KS4 = widget_label(KS, VALUE='[m/s]')  widget_control, KS2, set_droplist_select=mstate.infil_vars.Ks_type[j];--------------------------------------------------------------------------KI = widget_base(CB, /ROW, SPACE=ngap)  KI1 = widget_label(KI, VALUE='K_i: ')  KI2 = widget_droplist(KI, VALUE=types, UVALUE='KI_TYPE')  KI3 = widget_text(KI, VALUE=Ki_str, UVALUE='NONE', /EDITABLE, XSIZE=fsize)  KI4 = widget_label(KI, VALUE='[m/s]')  widget_control, KI2, set_droplist_select=mstate.infil_vars.Ki_type[j] ;--------------------------------------------------------------------------QS = widget_base(CB, /ROW, SPACE=ngap)  QS1 = widget_label(QS, VALUE='theta_s: ')  QS2 = widget_droplist(QS, VALUE=types, UVALUE='QS_TYPE')  QS3 = widget_text(QS, VALUE=qs_str, UVALUE='NONE', $                    /EDITABLE, XSIZE=fsize)  QS4 = widget_label(QS, VALUE='[unitless]', UVALUE='NONE')  widget_control, QS2, set_droplist_select=mstate.infil_vars.qs_type[j];--------------------------------------------------------------------------QI = widget_base(CB, /ROW, SPACE=ngap)  QI1 = widget_label(QI, VALUE='theta_i: ')  QI2 = widget_droplist(QI, VALUE=types, UVALUE='QI_TYPE')  QI3 = widget_text(QI, VALUE=qi_str, UVALUE='NONE', $                    /EDITABLE, XSIZE=fsize)  QI4 = widget_label(QI, VALUE='[unitless]', UVALUE='NONE')  widget_control, QI2, set_droplist_select=mstate.infil_vars.qi_type[j];--------------------------------------------------------------------------QR = widget_base(CB, /ROW, SPACE=ngap)  QR1 = widget_label(QR, VALUE='theta_r: ')  QR2 = widget_droplist(QR, VALUE=types, UVALUE='QR_TYPE')  QR3 = widget_text(QR, VALUE=qr_str, UVALUE='NONE', $                    /EDITABLE, XSIZE=fsize)  QR4 = widget_label(QR, VALUE='[unitless]', UVALUE='NONE')  widget_control, QR2, set_droplist_select=mstate.infil_vars.qr_type[j] ;--------------------------------------------------------------------------PB = widget_base(CB, /ROW, SPACE=ngap)  PB1 = widget_label(PB, VALUE='psi_B: ')  PB2 = widget_droplist(PB, VALUE=types, UVALUE='PB_TYPE')  PB3 = widget_text(PB, VALUE=pB_str, UVALUE='NONE', $                    /EDITABLE, XSIZE=fsize)  PB4 = widget_label(PB, VALUE='[meters]', UVALUE='NONE')  widget_control, PB2, set_droplist_select=mstate.infil_vars.pB_type[j] ;--------------------------------------------------------------------------PA = widget_base(CB, /ROW, SPACE=ngap)  PA1 = widget_label(PA, VALUE='psi_A: ')  PA2 = widget_droplist(PA, VALUE=types, UVALUE='PA_TYPE')  PA3 = widget_text(PA, VALUE=pA_str, UVALUE='NONE', $                    /EDITABLE, XSIZE=fsize)  PA4 = widget_label(PA, VALUE='[meters]', UVALUE='NONE')  widget_control, PA2, set_droplist_select=mstate.infil_vars.pA_type[j] ;--------------------------------------------------------------------------LA = widget_base(CB, /ROW, SPACE=ngap)  LA1 = widget_label(LA, VALUE='lambda: ')  LA2 = widget_droplist(LA, VALUE=types, UVALUE='LAM_TYPE')  LA3 = widget_text(LA, VALUE=lam_str, UVALUE='NONE', $                    /EDITABLE, XSIZE=fsize)  LA4 = widget_label(LA, VALUE='[unitless]')  widget_control, LA2, set_droplist_select=mstate.infil_vars.lam_type[j];--------------------------------------------------------------------------CC = widget_base(CB, /ROW, SPACE=ngap)  CC1 = widget_label(CC, VALUE='c: ')  CC2 = widget_droplist(CC, VALUE=types, UVALUE='C_TYPE')  CC3 = widget_text(CC, VALUE=c_str, UVALUE='NONE', /EDITABLE, XSIZE=fsize)  CC4 = widget_label(CC, VALUE='[unitless]')  widget_control, CC2, set_droplist_select=mstate.infil_vars.c_type[j] ;--------------------------------------------------------------------------DZ = widget_base(CB, /ROW, SPACE=ngap)  DZ1 = widget_label(DZ, VALUE='dz_nodes: ')  DZ2 = widget_droplist(DZ, VALUE=stype, UVALUE='DZ_TYPE')  DZ3 = widget_text(DZ, VALUE=dz_str, UVALUE='NONE', /EDITABLE, XSIZE=fsize)  DZ4 = widget_label(DZ, VALUE='[meters]');--------------------------------------------------------------------------NZ = widget_base(CB, /ROW, SPACE=ngap)  NZ1 = widget_label(NZ, VALUE='n_nodes: ')  NZ2 = widget_droplist(NZ, VALUE=stype, UVALUE='NZ_TYPE')  NZ3 = widget_text(NZ, VALUE=nz_str, UVALUE='NONE', $                    /EDITABLE, XSIZE=fsize)  NZ4 = widget_label(NZ, VALUE='[unitless]');--------------------------------------------------------------------------BZ = widget_label(CB, VALUE=' ', UVALUE='NONE');------------------;Align the widgets;------------------Align_Text_Boxes, [A11, KS1,KI1, QS1,QI1,QR1, PB1,PA1, CC1,LA1, DZ1,NZ1]Align_Text_Boxes, [A12, KS2,KI2, QS2,QI2,QR2, PB2,PA2, CC2,LA2, DZ2,NZ2]Align_Text_Boxes, [A13, KS3,KI3, QS3,QI3,QR3, PB3,PA3, CC3,LA3, DZ3,NZ3];-------------------------------------------------;Make last 2 droplists same size as others on Mac;Neither of these 2 methods work;-------------------------------------------------;Align_Text_Boxes, [CC2, DZ2, NZ2];------------------------------------;geom = widget_info(CC2, /geom);widget_control, DZ2, scr_xsize=geom.scr_xsize;widget_control, NZ2, scr_xsize=geom.scr_xsize;---------------------------------------------;Droplist to set params for a given soil type;---------------------------------------------ST = widget_base(CB, /ROW, SPACE=ngap)  ST1 = widget_label(ST, VALUE='Closest standard soil type: ')  types  = Soil_Types()  types  = Str_Pad(types, 1)  types2 = Soil_Types(/FORM2)  wt = where(types2 eq mstate.infil_vars.soil_type[j])  ST2 = widget_droplist(ST, VALUE=types, UVALUE='SOIL_TYPE')  widget_control, ST2, set_droplist_select=wt[0]  ST3 = widget_label(ST, VALUE=' ')
  ;*** Align_Text_Boxes, [ST2, A13]   ;(this doesn't work);----------------------;Back and Next buttons;----------------------space = 7BN = widget_base(CB, /ROW, SPACE=space)  BN0 = widget_label(BN, VALUE='Soil layer ' + jstr + ':   ')  BN1 = widget_button(BN, VALUE=Str_Pad('< Back'), UVALUE='BACK')  BN2 = widget_button(BN, VALUE=Str_Pad('Next >'), UVALUE='NEXT')  if (j eq 0) then widget_control, BN1, sensitive=0  nL = mstate.infil_vars.n_layers  if (j eq (nL-1)) then widget_control, BN2, sensitive=0;-----------------------;Store the text box IDs;-----------------------state.Ks_ID[j]  = KS3state.Ki_ID[j]  = KI3state.qs_ID[j]  = QS3state.qi_ID[j]  = QI3state.qr_ID[j]  = QR3state.pB_ID[j]  = PB3state.pA_ID[j]  = PA3state.lam_ID[j] = LA3state.c_ID[j]   = CC3state.dz_ID[j]  = DZ3state.nz_ID[j]  = NZ3;-----------------------------;Initialize the "types", used;for input error checking;-----------------------------state.Ks_type[j]  = mstate.infil_vars.Ks_type[j]state.Ki_type[j]  = mstate.infil_vars.Ki_type[j]state.qs_type[j]  = mstate.infil_vars.qs_type[j]state.qi_type[j]  = mstate.infil_vars.qi_type[j]state.qr_type[j]  = mstate.infil_vars.qr_type[j]state.pB_type[j]  = mstate.infil_vars.pB_type[j]state.pA_type[j]  = mstate.infil_vars.pA_type[j]state.lam_type[j] = mstate.infil_vars.lam_type[j]state.c_type[j]   = mstate.infil_vars.c_type[j];------------------------;Return the main base ID;------------------------RETURN, MBend;  GUI_Richards_Layer_Panel;*****************************************************************pro GUI_Richards_Eqn_Vars, leader ;-----------;Error trap;-----------No_Catch, statusCheck_Error_Status, status, OKif NOT(OK) then RETURNif (n_elements(leader) eq 0) then leader=0L ;-----------------------------------;Get current values from main state;-----------------------------------Get_TLB_State, leader, mstate, ALIVEif NOT(ALIVE) then RETURNn_layers = mstate.infil_vars.n_layers;------------------------------;Store the min precip duration;for possible warning to user;------------------------------dt_i = mstate.infil_vars.dt           ;[seconds]durs = *mstate.precip_vars.durations  ;[minutes]wd   = where(durs gt 0, nw)if (nw gt 0) then begin    dt_p = min(durs[wd] * 60d)        ;[seconds]endif else dt_p = dt_i;---------------------------;Get default timestep, etc.    (LATER TEST IF STABLE OR NOT);---------------------------dt_str = TF_String(mstate.infil_vars.dt)   ;[seconds];------------------------------------------;Store selected options in state structure;------------------------------------------state = { $leader_ID:leader, visible_panel: 0, $n_layers: n_layers, bases: lonarr(n_layers), $infil_dt_ID:0L, min_duration:dt_p, $;-------------------------------------;These soil layer vars are all arrays;-------------------------------------Ks_ID: lonarr(n_layers),  Ks_type:mstate.infil_vars.Ks_type, $Ki_ID: lonarr(n_layers),  Ki_type:mstate.infil_vars.Ki_type, $qs_ID: lonarr(n_layers),  qs_type:mstate.infil_vars.qs_type, $qi_ID: lonarr(n_layers),  qi_type:mstate.infil_vars.qi_type, $qr_ID: lonarr(n_layers),  qr_type:mstate.infil_vars.qr_type, $pB_ID: lonarr(n_layers),  pB_type:mstate.infil_vars.pB_type, $pA_ID: lonarr(n_layers),  pA_type:mstate.infil_vars.pA_type, $lam_ID:lonarr(n_layers), lam_type:mstate.infil_vars.lam_type, $c_ID:  lonarr(n_layers),   c_type:mstate.infil_vars.c_type, $dz_ID: lonarr(n_layers),  $    ;(always scalar type)
nz_ID: lonarr(n_layers),  $    ;(always scalar type)soil_type: mstate.infil_vars.soil_type };-----------------;Main base widget;-----------------Create_TLB, MB, TITLE='Infiltration Variables: Richards Equation', $            /COLUMN, LEADER=leader   ;***, /MODAL);--------------------------------;Create the set of wizard panels;--------------------------------PP = widget_base(MB)for j=0,(n_layers-1) do begin    state.bases[j] = GUI_Richards_Layer_Panel(PP, state, mstate, j)endfor;------------------------------;Unmap all but the first panel;------------------------------onoff = bytarr(n_layers)onoff[0] = 1bfor k=0,(n_layers-1) do widget_control, state.bases[k], MAP=onoff[k];------------------------------;Get the infiltration timestep;------------------------------CB = widget_base(MB, /COLUMN, SPACE=ngap, /FRAME)TI = widget_base(CB, /ROW, SPACE=ngap)  TI1 = widget_label(TI, VALUE='Infiltration process timestep: ')  TI2 = widget_text(TI, VALUE=dt_str, UVALUE='NONE', /EDITABLE, XSIZE=10)  TI3 = widget_label(TI, VALUE='[seconds / timestep]')  state.infil_dt_ID = TI2L1 = widget_label(CB, VALUE=' ', UVALUE='NONE')L2 = widget_label(CB, UVALUE='NONE', /ALIGN_LEFT, $            VALUE='Note: Timestep must not exceed min precip duration.');-----------------------------;Make framed bases same width;-----------------------------geom = widget_info(PP, /geometry)for k=0,(n_layers-1) do $    widget_control, state.bases[k], SCR_XSIZE=(geom.scr_xsize + 6);------------------;Bottom button bar;------------------space = 7A = widget_base(MB, /ROW, SPACE=space)  A1 = widget_button(A, VALUE=Str_Pad('OK'), UVALUE='OK')  A2 = widget_button(A, VALUE=Str_Pad('Help'), UVALUE='HELP')  A3 = widget_button(A, VALUE=Str_Pad('Cancel'), UVALUE='CANCEL');------------------------------------;Realize widgets and wait for events ;------------------------------------Realize_TLB, MB, state, 'GUI_Richards_Eqn_Vars', XOFF=480, TW=TWEND;  GUI_Richards_Eqn_Vars;*****************************************************************pro GUI_Save_Infil_Vars_event, event;-----------;Error trap;-----------CATCH, statusTrace_Error, status, event, OKif NOT(OK) then RETURNGet_Event_Uvalue, event, uvalue, statecase (uvalue) of;*********'OK' : $;*********beginRead_Text_Box, state.save_grid_dt_ID, save_grid_dt, OK, /DOUBLEif NOT(OK) then RETURNsave_grid_dt = (save_grid_dt * 60d)  ;[min -> sec];--------------------------------------------------------------------Read_Text_Box, state.save_pixels_dt_ID, save_pixels_dt, OK, /DOUBLEif NOT(OK) then RETURNsave_pixels_dt = (save_pixels_dt * 60d)  ;[min -> sec];------------------------;Get leader's state vars;------------------------Get_TLB_State, state.leader_ID, mstate, ALIVEif NOT(ALIVE) then RETURN;----------------------------------------------RICHARDS = (mstate.infil_vars.method eq 4)if (RICHARDS) then begin    Read_Text_Box, state.save_stack_dt_ID, save_stack_dt, OK, /DOUBLE    if NOT(OK) then RETURN    save_stack_dt = (save_stack_dt * 60d)  ;[min -> sec]    ;---------------------------------------------------------------------    Read_Text_Box, state.save_profile_dt_ID, save_profile_dt, OK, /DOUBLE    if NOT(OK) then RETURN    save_profile_dt = (save_profile_dt * 60d)  ;[min -> sec]    ;------------------------    ;Upload values to leader    ;------------------------    mstate.infil_vars.save_stack_dt   = save_stack_dt    mstate.infil_vars.save_profile_dt = save_profile_dtendif;------------------------;Upload values to leader;------------------------mstate.infil_vars.save_grid_dt    = save_grid_dtmstate.infil_vars.save_pixels_dt  = save_pixels_dt;--------------------------------------------------------mstate.infil_vars.save_v0_grids  = state.save_v0_gridsmstate.infil_vars.save_q0_grids  = state.save_q0_grids mstate.infil_vars.save_I_grids   = state.save_I_gridsmstate.infil_vars.save_Zw_grids  = state.save_Zw_grids;--------------------------------------------------------mstate.infil_vars.save_v0_pixels = state.save_v0_pixelsmstate.infil_vars.save_q0_pixels = state.save_q0_pixelsmstate.infil_vars.save_I_pixels  = state.save_I_pixelsmstate.infil_vars.save_Zw_pixels = state.save_Zw_pixels;--------------------------------------------------------mstate.infil_vars.save_q_stacks  = state.save_q_stacks mstate.infil_vars.save_p_stacks  = state.save_p_stacks mstate.infil_vars.save_K_stacks  = state.save_K_stacks mstate.infil_vars.save_v_stacks  = state.save_v_stacks ;---------------------------------------------------------mstate.infil_vars.save_q_profiles = state.save_q_profiles mstate.infil_vars.save_p_profiles = state.save_p_profiles mstate.infil_vars.save_K_profiles = state.save_K_profiles mstate.infil_vars.save_v_profiles = state.save_v_profiles ;---------------------------------;Collect the output RTS filenames;---------------------------------if (state.save_v0_grids) then begin    Read_Text_Box, state.v0_rts_file_ID, v0_rts_file, OK, /FILE    if NOT(OK) then RETURN    Check_Overwrite, v0_rts_file, OK    if NOT(OK) then RETURN    mstate.infil_vars.v0_rts_file = v0_rts_fileendif;---------------------------------------------------------------------if (state.save_q0_grids) then begin    Read_Text_Box, state.q0_rts_file_ID, q0_rts_file, OK, /FILE    if NOT(OK) then RETURN    Check_Overwrite, q0_rts_file, OK    if NOT(OK) then RETURN    mstate.infil_vars.q0_rts_file = q0_rts_fileendif;---------------------------------------------------------------------if (state.save_I_grids) then begin    Read_Text_Box, state.I_rts_file_ID, I_rts_file, OK, /FILE    if NOT(OK) then RETURN    Check_Overwrite, I_rts_File, OK    if NOT(OK) then RETURN    mstate.infil_vars.I_rts_file = I_rts_fileendif;---------------------------------------------------------------------if (state.save_Zw_grids) then begin    Read_Text_Box, state.Zw_rts_file_ID, Zw_rts_file, OK, /FILE    if NOT(OK) then RETURN    Check_Overwrite, Zw_rts_file, OK    if NOT(OK) then RETURN    mstate.infil_vars.Zw_rts_file = Zw_rts_fileendif;-----------------------------------------;Collect the output time series filenames;-----------------------------------------if (state.save_v0_pixels) then begin    Read_Text_Box, state.v0_out_file_ID, v0_out_file, OK, /FILE    if NOT(OK) then RETURN    Check_Overwrite, v0_out_File, OK    if NOT(OK) then RETURN    mstate.infil_vars.v0_out_file = v0_out_fileendif;---------------------------------------------------------------------if (state.save_q0_pixels) then begin    Read_Text_Box, state.q0_out_file_ID, q0_out_file, OK, /FILE    if NOT(OK) then RETURN    Check_Overwrite, q0_out_File, OK    if NOT(OK) then RETURN    mstate.infil_vars.q0_out_file = q0_out_fileendif;---------------------------------------------------------------------if (state.save_I_pixels) then begin    Read_Text_Box, state.I_out_file_ID, I_out_file, OK, /FILE    if NOT(OK) then RETURN    Check_Overwrite, I_out_File, OK    if NOT(OK) then RETURN    mstate.infil_vars.I_out_file = I_out_fileendif;---------------------------------------------------------------------if (state.save_Zw_pixels) then begin    Read_Text_Box, state.Zw_out_file_ID, Zw_out_file, OK, /FILE    if NOT(OK) then RETURN    Check_Overwrite, Zw_out_File, OK    if NOT(OK) then RETURN    mstate.infil_vars.Zw_out_file = Zw_out_fileendifif (RICHARDS) then begin;-----------------------------------------;Collect the output RT3 (stack) filenames;-----------------------------------------if (state.save_q_stacks) then begin    Read_Text_Box, state.q_stack_file_ID, q_stack_file, OK, /FILE    if NOT(OK) then RETURN    Check_Overwrite, q_stack_file, OK    if NOT(OK) then RETURN    mstate.infil_vars.q_stack_file = q_stack_fileendif;---------------------------------------------------------------------if (state.save_p_stacks) then begin    Read_Text_Box, state.p_stack_file_ID, p_stack_file, OK, /FILE    if NOT(OK) then RETURN    Check_Overwrite, p_stack_file, OK    if NOT(OK) then RETURN    mstate.infil_vars.p_stack_file = p_stack_fileendif;---------------------------------------------------------------------if (state.save_K_stacks) then begin    Read_Text_Box, state.K_stack_file_ID, K_stack_file, OK, /FILE    if NOT(OK) then RETURN    Check_Overwrite, K_stack_file, OK    if NOT(OK) then RETURN    mstate.infil_vars.K_stack_file = K_stack_fileendif;---------------------------------------------------------------------if (state.save_v_stacks) then begin    Read_Text_Box, state.v_stack_file_ID, v_stack_file, OK, /FILE    if NOT(OK) then RETURN    Check_Overwrite, v_stack_file, OK    if NOT(OK) then RETURN    mstate.infil_vars.v_stack_file = v_stack_fileendif;-------------------------------------;Collect the output profile filenames;-------------------------------------if (state.save_q_profiles) then begin    Read_Text_Box, state.q_profile_file_ID, q_profile_file, OK, /FILE    if NOT(OK) then RETURN    Check_Overwrite, q_profile_file, OK    if NOT(OK) then RETURN    mstate.infil_vars.q_profile_file = q_profile_fileendif;---------------------------------------------------------------------if (state.save_p_profiles) then begin    Read_Text_Box, state.p_profile_file_ID, p_profile_file, OK, /FILE    if NOT(OK) then RETURN    Check_Overwrite, p_profile_file, OK    if NOT(OK) then RETURN    mstate.infil_vars.p_profile_file = p_profile_fileendif;---------------------------------------------------------------------if (state.save_K_profiles) then begin    Read_Text_Box, state.K_profile_file_ID, K_profile_file, OK, /FILE    if NOT(OK) then RETURN    Check_Overwrite, K_profile_file, OK    if NOT(OK) then RETURN    mstate.infil_vars.K_profile_file = K_profile_fileendif;---------------------------------------------------------------------if (state.save_v_profiles) then begin    Read_Text_Box, state.v_profile_file_ID, v_profile_file, OK, /FILE    if NOT(OK) then RETURN    Check_Overwrite, v_profile_file, OK    if NOT(OK) then RETURN    mstate.infil_vars.v_profile_file = v_profile_fileendifendif  ;**** (IF (RICHARDS));---------------------------------------------------------------------widget_control, state.leader_ID, set_uvalue=mstateClose_Dialog, event.topend;********************'SAVE_V0_GRIDS' : $;********************beginstate.save_v0_grids = (1b - state.save_v0_grids)widget_control, state.v0_rts_file_ID, sensitive=state.save_v0_gridsend;********************'SAVE_Q0_GRIDS' : $;********************beginstate.save_q0_grids = (1b - state.save_q0_grids)widget_control, state.q0_rts_file_ID, sensitive=state.save_q0_gridsend;*******************'SAVE_I_GRIDS' : $;*******************beginstate.save_I_grids = (1b - state.save_I_grids)widget_control, state.I_rts_file_ID, sensitive=state.save_I_gridsend;********************'SAVE_ZW_GRIDS' : $;********************begin
state.save_Zw_grids = (1b - state.save_Zw_grids)widget_control, state.Zw_rts_file_ID, sensitive=state.save_Zw_gridsend;*********************'SAVE_V0_PIXELS' : $;*********************beginstate.save_v0_pixels = (1b - state.save_v0_pixels)widget_control, state.v0_out_file_ID, sensitive=state.save_v0_pixels end;*********************'SAVE_Q0_PIXELS' : $;*********************beginstate.save_q0_pixels = (1b - state.save_q0_pixels)widget_control, state.q0_out_file_ID, sensitive=state.save_q0_pixels end;********************'SAVE_I_PIXELS' : $;********************beginstate.save_I_pixels = (1b - state.save_I_pixels)widget_control, state.I_out_file_ID, sensitive=state.save_I_pixels end;********************'SAVE_ZW_PIXELS' : $;********************beginstate.save_Zw_pixels = (1b - state.save_Zw_pixels)widget_control, state.Zw_out_file_ID, sensitive=state.save_Zw_pixels end;********************'SAVE_Q_STACKS' : $;********************beginstate.save_q_stacks = (1b - state.save_q_stacks)widget_control, state.q_stack_file_ID, sensitive=state.save_q_stacksend;********************'SAVE_P_STACKS' : $;********************beginstate.save_p_stacks = (1b - state.save_p_stacks)widget_control, state.p_stack_file_ID, sensitive=state.save_p_stacksend;********************'SAVE_K_STACKS' : $;********************beginstate.save_K_stacks = (1b - state.save_K_stacks)widget_control, state.K_stack_file_ID, sensitive=state.save_K_stacksend;********************'SAVE_V_STACKS' : $;********************beginstate.save_v_stacks = (1b - state.save_v_stacks)widget_control, state.v_stack_file_ID, sensitive=state.save_v_stacksend;**********************'SAVE_Q_PROFILES' : $;**********************beginstate.save_q_profiles = (1b - state.save_q_profiles)widget_control, state.q_profile_file_ID, sensitive=state.save_q_profilesend;**********************'SAVE_P_PROFILES' : $;**********************beginstate.save_p_profiles = (1b - state.save_p_profiles)widget_control, state.p_profile_file_ID, sensitive=state.save_p_profilesend;**********************'SAVE_K_PROFILES' : $;**********************beginstate.save_K_profiles = (1b - state.save_K_profiles)widget_control, state.K_profile_file_ID, sensitive=state.save_K_profilesend;**********************'SAVE_V_PROFILES' : $;**********************beginstate.save_v_profiles = (1b - state.save_v_profiles)widget_control, state.v_profile_file_ID, sensitive=state.save_v_profilesend;***********'HELP' : $;***********beginmsg = [' ',$'This dialog allows you to specify which computed infiltration ',$'variables that you want to save as a grid sequence or time ',$'series and the sampling timestep. ', ' ']GUI_Help, msg, state.leader_ID, TITLE='Save Infiltration Variables Help'end;************'CANCEL' : $;************Close_Dialog, event.topELSE : dum=0endcaseif (uvalue ne 'CANCEL') AND $   (uvalue ne 'OK') then $    widget_control, event.top, set_uvalue=state END;  GUI_Save_Infil_Vars_event;*****************************************************************pro GUI_Save_Infil_Vars, leader, RICHARDS=RICHARDS;-----------;Error trap;-----------No_Catch, statusCheck_Error_Status, status, OKif NOT(OK) then RETURNif (n_elements(leader) eq 0) then RETURNRICHARDS = keyword_set(RICHARDS);------------------------;Get the dialog defaults;------------------------Get_TLB_State, leader, mstate, ALIVEif NOT(ALIVE) then RETURN;---------------------------------------------------------gstr = TF_String(mstate.infil_vars.save_grid_dt    / 60d)pstr = TF_String(mstate.infil_vars.save_pixels_dt  / 60d)sstr = TF_String(mstate.infil_vars.save_stack_dt   / 60d)rstr = TF_String(mstate.infil_vars.save_profile_dt / 60d);---------------------------------------------------------save_v0_grids  = mstate.infil_vars.save_v0_gridssave_q0_grids  = mstate.infil_vars.save_q0_gridssave_I_grids   = mstate.infil_vars.save_I_gridssave_Zw_grids  = mstate.infil_vars.save_Zw_grids ;----------------------------------------------------save_v0_pixels = mstate.infil_vars.save_v0_pixelssave_q0_pixels = mstate.infil_vars.save_q0_pixelssave_I_pixels  = mstate.infil_vars.save_I_pixelssave_Zw_pixels = mstate.infil_vars.save_Zw_pixels;----------------------------------------------------save_q_stacks  = mstate.infil_vars.save_q_stacks save_p_stacks  = mstate.infil_vars.save_p_stacks save_K_stacks  = mstate.infil_vars.save_K_stacks save_v_stacks  = mstate.infil_vars.save_v_stacks ;----------------------------------------------------save_q_profiles = mstate.infil_vars.save_q_profiles save_p_profiles = mstate.infil_vars.save_p_profiles save_K_profiles = mstate.infil_vars.save_K_profiles save_v_profiles = mstate.infil_vars.save_v_profiles ;----------------------------------------------------v0_rts_file = mstate.infil_vars.v0_rts_fileq0_rts_file = mstate.infil_vars.q0_rts_fileI_rts_file  = mstate.infil_vars.I_rts_fileZw_rts_file = mstate.infil_vars.Zw_rts_file;-------------------------------------------------v0_out_file = mstate.infil_vars.v0_out_fileq0_out_file = mstate.infil_vars.q0_out_fileI_out_file = mstate.infil_vars.I_out_fileZw_out_file = mstate.infil_vars.Zw_out_file;-------------------------------------------------q_stack_file = mstate.infil_vars.q_stack_filep_stack_file = mstate.infil_vars.p_stack_fileK_stack_file = mstate.infil_vars.K_stack_filev_stack_file = mstate.infil_vars.v_stack_file;-------------------------------------------------q_profile_file = mstate.infil_vars.q_profile_filep_profile_file = mstate.infil_vars.p_profile_fileK_profile_file = mstate.infil_vars.K_profile_filev_profile_file = mstate.infil_vars.v_profile_file;--------------------;Used before 7/27/06;--------------------;;prefix = mstate.run_vars.run_prefix;----------------------------------------------------------------;;if (v0_rts_file eq '') then v0_rts_file=(prefix + '_2D-v0.rts');;if (q0_rts_file eq '') then q0_rts_file=(prefix + '_2D-q0.rts');;if (I_rts_file eq '')  then  I_rts_file=(prefix + '_2D-I.rts');;if (Zw_rts_file eq '') then Zw_rts_file=(prefix + '_2D-Zw.rts');----------------------------------------------------------------;;if (v0_out_file eq '') then v0_out_file=(prefix + '_0D-v0.txt');;if (q0_out_file eq '') then q0_out_file=(prefix + '_0D-q0.txt');;if (I_out_file eq '')  then  I_out_file=(prefix + '_0D-I.txt');;if (Zw_out_file eq '') then Zw_out_file=(prefix + '_0D-Zw.txt');----------------------------------------------------------------;;if (q_stack_file eq '') then q_stack_file=(prefix + '_3D-q.rt3');;if (p_stack_file eq '') then p_stack_file=(prefix + '_3D-p.rt3');;if (K_stack_file eq '') then K_stack_file=(prefix + '_3D-K.rt3');;if (v_stack_file eq '') then v_stack_file=(prefix + '_3D-v.rt3');--------------------------------------------------------------------;;if (q_profile_file eq '') then q_profile_file=(prefix + '_1D-q.txt');;if (p_profile_file eq '') then p_profile_file=(prefix + '_1D_p.txt');;if (K_profile_file eq '') then K_profile_file=(prefix + '_1D_K.txt');;if (v_profile_file eq '') then v_profile_file=(prefix + '_1D_v.txt');------------------------------------;Structure to store selected options;------------------------------------state = { $leader_ID:leader, $save_v0_grids: save_v0_grids, v0_rts_file_ID:0L, $save_q0_grids: save_q0_grids, q0_rts_file_ID:0L, $save_I_grids:  save_I_grids,  I_rts_file_ID: 0L, $save_Zw_grids: save_Zw_grids, Zw_rts_file_ID:0L, $;-------------------------------------------------------save_v0_pixels: save_v0_pixels, v0_out_file_ID:0L, $save_q0_pixels: save_q0_pixels, q0_out_file_ID:0L, $save_I_pixels:  save_I_pixels,  I_out_file_ID: 0L, $save_Zw_pixels: save_Zw_pixels, Zw_out_file_ID:0L, $;-------------------------------------------------------save_q_stacks: save_q_stacks,  q_stack_file_ID:  0L, $save_p_stacks: save_p_stacks,  p_stack_file_ID:  0L, $save_K_stacks: save_K_stacks,  K_stack_file_ID:  0L, $save_v_stacks: save_v_stacks,  v_stack_file_ID:  0L, $;-------------------------------------------------------------save_q_profiles: save_q_profiles, q_profile_file_ID:  0L, $save_p_profiles: save_p_profiles, p_profile_file_ID:  0L, $save_K_profiles: save_K_profiles, K_profile_file_ID:  0L, $save_v_profiles: save_v_profiles, v_profile_file_ID:  0L, $;-------------------------------------------------------------save_grid_dt_ID:    0L, $save_pixels_dt_ID:  0L, $save_stack_dt_ID:   0L, $save_profile_dt_ID: 0L }ngap = 6XS1 = 20;-----------------;Main base widget;-----------------Create_TLB, MB, TITLE='Save Infiltration Variables', $            /COLUMN, LEADER=leaderMID  = widget_base(MB, /ROW)LCOL = widget_base(MID, /COLUMN)RCOL = widget_base(MID, /COLUMN);---------------------;Option to save grids ;---------------------SG = widget_base(LCOL, /COL, /FRAME)  SG1 = widget_base(SG, /ROW, SPACE=ngap)    ;---------------------------------------------------------------------    SG11 = widget_base(SG1, /COL, SPACE=ngap)      SG111 = widget_label(SG11, VALUE='Grids to save: ', $                          UVALUE='NONE', /ALIGN_LEFT)      SG112 = widget_base(SG11, /COL, /NONEXCLUSIVE)        SG1121 = widget_button(SG112, VALUE='Infiltration rate [m/s]',  $                               UVALUE='SAVE_V0_GRIDS')        SG1122 = widget_button(SG112, VALUE='Surf. soil moisture [none]',  $                               UVALUE='SAVE_Q0_GRIDS')        SG1123 = widget_button(SG112, VALUE='Total infil. depth [m]',  $                               UVALUE='SAVE_I_GRIDS')        SG1124 = widget_button(SG112, VALUE='Wetting front depth [m]',  $                               UVALUE='SAVE_ZW_GRIDS')        if (save_v0_grids) then widget_control,SG1121,/set_button        if (save_q0_grids) then widget_control,SG1122,/set_button        if (save_I_grids)  then widget_control,SG1123,/set_button        if (save_Zw_grids) then widget_control,SG1124,/set_button        if (mstate.infil_vars.method ne 4) then begin            widget_control, SG1122, sensitive=0        ;****************            widget_control, SG1124, sensitive=0        endif    ;---------------------------------------------------------------------    SG12 = widget_base(SG1, /COL, SPACE=ngap)      SG121 = widget_label(SG12, VALUE='Output filename  (*.rts): ', $                           UVALUE='NONE', /ALIGN_LEFT)      SG122 = widget_base(SG12, /COL)        SG1221 = widget_text(SG122, VALUE=v0_rts_file, $                             UVALUE='NONE', /EDITABLE, XSIZE=XS1)        SG1222 = widget_text(SG122, VALUE=q0_rts_file, $                             UVALUE='NONE', /EDITABLE, XSIZE=XS1)        SG1223 = widget_text(SG122, VALUE=I_rts_file, $                             UVALUE='NONE', /EDITABLE, XSIZE=XS1)        SG1224 = widget_text(SG122, VALUE=Zw_rts_file, $                             UVALUE='NONE', /EDITABLE, XSIZE=XS1)      widget_control, SG1221, sensitive=save_v0_grids      widget_control, SG1222, sensitive=save_q0_grids       widget_control, SG1223, sensitive=save_I_grids      widget_control, SG1224, sensitive=save_Zw_grids      state.v0_rts_file_ID = SG1221      state.q0_rts_file_ID = SG1222      state.I_rts_file_ID  = SG1223      state.Zw_rts_file_ID = SG1224  ;---------------------------------------------------------------------  SG2 = widget_base(SG, /ROW, SPACE=ngap)    SG21 = widget_label(SG2, VALUE='At this timestep: ', UVALUE='NONE')    SG22 = widget_text(SG2, VALUE=gstr, UVALUE='NONE', $                       /EDITABLE, XSIZE=XS1)    SG23 = widget_label(SG2, VALUE='[min]', UVALUE='NONE')    state.save_grid_dt_ID = SG22;----------------------------;Option to save pixel values;----------------------------SV = widget_base(LCOL, /COL, /FRAME)  SV1 = widget_base(SV, /ROW, SPACE=ngap)    ;---------------------------------------------------------------------    SV11 = widget_base(SV1, /COL, SPACE=ngap)      SV111 = widget_label(SV11, VALUE='Values to save: ', $                           UVALUE='NONE', /ALIGN_LEFT)      SV112 = widget_base(SV11, /COL, /NONEXCLUSIVE)        SV1121 = widget_button(SV112, VALUE='Infiltration rate [m/s]',  $                               UVALUE='SAVE_V0_PIXELS')        SV1122 = widget_button(SV112, VALUE='Surf. soil moisture [none]',  $                               UVALUE='SAVE_Q0_PIXELS')        SV1123 = widget_button(SV112, VALUE='Total infil. depth [m]',  $                               UVALUE='SAVE_I_PIXELS')        SV1124 = widget_button(SV112, VALUE='Wetting front depth [m]',  $                               UVALUE='SAVE_ZW_PIXELS')        if (mstate.infil_vars.method ne 4) then begin            widget_control, SV1122, sensitive=0        ;************************            widget_control, SV1124, sensitive=0        endif        if (save_v0_pixels) then widget_control,SV1121,/set_button        if (save_q0_pixels) then widget_control,SV1122,/set_button         if (save_I_pixels)  then widget_control,SV1123,/set_button        if (save_Zw_pixels) then widget_control,SV1124,/set_button    ;---------------------------------------------------------------------    SV12 = widget_base(SV1, /COL, SPACE=ngap)      SV121 = widget_label(SV12, VALUE='Output filename  (*.txt): ', $                           UVALUE='NONE', /ALIGN_LEFT)      SV122 = widget_base(SV12, /COL)        SV1221 = widget_text(SV122, VALUE=v0_out_file, $                             UVALUE='NONE', /EDITABLE, XSIZE=XS1)        SV1222 = widget_text(SV122, VALUE=q0_out_file, $                             UVALUE='NONE', /EDITABLE, XSIZE=XS1)        SV1223 = widget_text(SV122, VALUE=I_out_file, $                             UVALUE='NONE', /EDITABLE, XSIZE=XS1)        SV1224 = widget_text(SV122, VALUE=Zw_out_file, $                             UVALUE='NONE', /EDITABLE, XSIZE=XS1)      widget_control, SV1221, sensitive=save_v0_pixels      widget_control, SV1222, sensitive=save_q0_pixels      widget_control, SV1223, sensitive=save_I_pixels      widget_control, SV1224, sensitive=save_Zw_pixels      state.v0_out_file_ID = SV1221      state.q0_out_file_ID = SV1222      state.I_out_file_ID  = SV1223      state.Zw_out_file_ID = SV1224  ;---------------------------------------------------------------------  SV2 = widget_base(SV, /ROW, SPACE=ngap)    SV21 = widget_label(SV2, VALUE='At this timestep: ', UVALUE='NONE')    SV22 = widget_text(SV2, VALUE=pstr, UVALUE='NONE', $                       /EDITABLE, XSIZE=XS1)    SV23 = widget_label(SV2, VALUE='[min]', UVALUE='NONE')    state.save_pixels_dt_ID = SV22;-----------------------------------------;Additional options for Richards equation;-----------------------------------------if (RICHARDS) then begin;----------------------;Option to save stacks ;----------------------SS = widget_base(RCOL, /COL, /FRAME)  SS1 = widget_base(SS, /ROW, SPACE=ngap)    ;---------------------------------------------------------------------    SS11 = widget_base(SS1, /COL, SPACE=ngap)      SS111 = widget_label(SS11, VALUE='Stacks to save: ', $                          UVALUE='NONE', /ALIGN_LEFT)      SS112 = widget_base(SS11, /COL, /NONEXCLUSIVE)        SS1121 = widget_button(SS112, VALUE='Soil moisture, theta [none]',  $                               UVALUE='SAVE_Q_STACKS')        SS1122 = widget_button(SS112, VALUE='Pressure head, psi [meters]',  $                               UVALUE='SAVE_P_STACKS')        SS1123 = widget_button(SS112, VALUE='Hydraulic conductivity [m/s]',  $                               UVALUE='SAVE_K_STACKS')        SS1124 = widget_button(SS112, VALUE='Vertical flow rate [m/s]',  $                               UVALUE='SAVE_V_STACKS')        if (save_q_stacks) then widget_control,SS1121,/set_button        if (save_p_stacks) then widget_control,SS1122,/set_button        if (save_K_stacks) then widget_control,SS1123,/set_button        if (save_v_stacks) then widget_control,SS1124,/set_button    ;---------------------------------------------------------------------    SS12 = widget_base(SS1, /COL, SPACE=ngap)      SS121 = widget_label(SS12, VALUE='Output filename  (*.rt3): ', $                           UVALUE='NONE', /ALIGN_LEFT)      SS122 = widget_base(SS12, /COL)        SS1221 = widget_text(SS122, VALUE=q_stack_file, $                             UVALUE='NONE', /EDITABLE, XSIZE=XS1)        SS1222 = widget_text(SS122, VALUE=p_stack_file, $                             UVALUE='NONE', /EDITABLE, XSIZE=XS1)        SS1223 = widget_text(SS122, VALUE=K_stack_file, $                             UVALUE='NONE', /EDITABLE, XSIZE=XS1)        SS1224 = widget_text(SS122, VALUE=v_stack_file, $                             UVALUE='NONE', /EDITABLE, XSIZE=XS1)      widget_control, SS1221, sensitive=save_q_stacks      widget_control, SS1222, sensitive=save_p_stacks      widget_control, SS1223, sensitive=save_K_stacks      widget_control, SS1224, sensitive=save_v_stacks      state.q_stack_file_ID = SS1221      state.p_stack_file_ID = SS1222      state.K_stack_file_ID = SS1223      state.v_stack_file_ID = SS1224  ;---------------------------------------------------------------------  SS2 = widget_base(SS, /ROW, SPACE=ngap)    SS21 = widget_label(SS2, VALUE='At this timestep: ', UVALUE='NONE')    SS22 = widget_text(SS2, VALUE=sstr, UVALUE='NONE', $                       /EDITABLE, XSIZE=XS1)    SS23 = widget_label(SS2, VALUE='[min]', UVALUE='NONE')    state.save_stack_dt_ID = SS22;------------------------------;Option to save depth profiles;------------------------------SP = widget_base(RCOL, /COL, /FRAME)  SP1 = widget_base(SP, /ROW, SPACE=ngap)    ;---------------------------------------------------------------------    SP11 = widget_base(SP1, /COL, SPACE=ngap)      SP111 = widget_label(SP11, VALUE='Depth profiles to save: ', $                           UVALUE='NONE', /ALIGN_LEFT)      SP112 = widget_base(SP11, /COL, /NONEXCLUSIVE)        SP1121 = widget_button(SP112, VALUE='Soil moisture, theta [none]',  $                               UVALUE='SAVE_Q_PROFILES')        SP1122 = widget_button(SP112, VALUE='Pressure head, psi [meters]',  $                               UVALUE='SAVE_P_PROFILES')        SP1123 = widget_button(SP112, VALUE='Hydraulic conductivity [m/s]', $                               UVALUE='SAVE_K_PROFILES')        SP1124 = widget_button(SP112, VALUE='Vertical flow rate [m/s]',  $                               UVALUE='SAVE_V_PROFILES')        if (save_q_profiles) then widget_control,SP1121,/set_button        if (save_p_profiles) then widget_control,SP1122,/set_button         if (save_K_profiles) then widget_control,SP1123,/set_button        if (save_v_profiles) then widget_control,SP1124,/set_button    ;---------------------------------------------------------------------    SP12 = widget_base(SP1, /COL, SPACE=ngap)      SP121 = widget_label(SP12, VALUE='Output filename  (*.txt): ', $                           UVALUE='NONE', /ALIGN_LEFT)      SP122 = widget_base(SP12, /COL)        SP1221 = widget_text(SP122, VALUE=q_profile_file, $                             UVALUE='NONE', /EDITABLE, XSIZE=XS1)        SP1222 = widget_text(SP122, VALUE=p_profile_file, $                             UVALUE='NONE', /EDITABLE, XSIZE=XS1)        SP1223 = widget_text(SP122, VALUE=K_profile_file, $                             UVALUE='NONE', /EDITABLE, XSIZE=XS1)        SP1224 = widget_text(SP122, VALUE=v_profile_file, $                             UVALUE='NONE', /EDITABLE, XSIZE=XS1)      widget_control, SP1221, sensitive=save_q_profiles       widget_control, SP1222, sensitive=save_p_profiles       widget_control, SP1223, sensitive=save_K_profiles       widget_control, SP1224, sensitive=save_v_profiles       state.q_profile_file_ID = SP1221      state.p_profile_file_ID = SP1222      state.K_profile_file_ID = SP1223      state.v_profile_file_ID = SP1224  ;---------------------------------------------------------------------  SP2 = widget_base(SP, /ROW, SPACE=ngap)    SP21 = widget_label(SP2, VALUE='At this timestep: ', UVALUE='NONE')    SP22 = widget_text(SP2, VALUE=rstr, UVALUE='NONE', $                       /EDITABLE, XSIZE=XS1)    SP23 = widget_label(SP2, VALUE='[min]', UVALUE='NONE')    state.save_profile_dt_ID = SP22  ;---------------------------------------------------------------------endif  ;(if (RICHARDS) *******************************;------------------;Bottom button bar;------------------CW_Button_Bar, MB, /OK, /HELP, /CANCEL;------------------------------------;Realize widgets and wait for events ;------------------------------------XOFF = 480Realize_TLB, MB, state, 'GUI_Save_Infil_Vars', $             XOFF=XOFF  ;***, TW=[F12, F22]END;  GUI_Save_Infil_Vars;*****************************************************************;*****************************************************************;  3/6/08  These are unused now.  Are they obsolete?;*****************************************************************pro GUI_Green_Ampt1_Formulas_event, event;-----------;Error trap;-----------CATCH, statusTrace_Error, status, event, OKif NOT(OK) then RETURNGet_Event_Uvalue, event, uvalue, statecase (uvalue) of;*********'OK' : $;*********Close_Dialog, event.top ;***********'HELP' : $;***********Show_HTML_Help, 'infil_Green-Ampt_formulas.htm';************'CANCEL' : $;************Close_Dialog, event.topELSE : dum=0endcaseif (uvalue ne 'CANCEL') AND $   (uvalue ne 'OK') then $    widget_control, event.top, set_uvalue=state END;  GUI_Green_Ampt1_Formulas_event;*****************************************************************pro GUI_Green_Ampt1_Formulas, leader;-----------;Error trap;-----------No_Catch, statusCheck_Error_Status, status, OKif NOT(OK) then RETURNif (n_elements(leader) eq 0) then leader=0L ;------------------------------------;Structure to store selected options;------------------------------------state = {leader_ID:leader}ngap = 6fsize = 20types = Model_Input_Types()XS = 44;-----------------;Main base widget;-----------------Create_TLB, MB, /COLUMN, LEADER=leader, $            TITLE='Infiltration Formulas: Green-Ampt1 Method'A = widget_base(MB, /COLUMN, /FRAME);------------------;Show the formulas;------------------F1 = widget_base(A, /ROW, SPACE=ngap)  F11 = widget_label(F1, VALUE='Formula 1:', UVALUE='NONE')  v1  = ' fc = [dK * (M + F) / F] + Ki '  F12 = widget_text(F1, VALUE=v1, UVALUE='NONE', XSIZE=XS) ;***, /EDITABLE)  F13 = widget_label(F1, VALUE='[m/sec]', UVALUE='NONE');---------------------------------------------------------------------F2 = widget_base(A, /ROW, SPACE=ngap)  F21 = widget_label(F2, VALUE='Formula 2:', UVALUE='NONE')  v2  = ' dK = (Ks  Ki)'  F22 = widget_text(F2, VALUE=v2, UVALUE='NONE', XSIZE=XS) ;*** /EDITABLE)  F23 = widget_label(F2, VALUE='[m/sec]', UVALUE='NONE');---------------------------------------------------------------------F3 = widget_base(A, /ROW, SPACE=ngap)  F31 = widget_label(F3, VALUE='Formula 3:', UVALUE='NONE')  v3  = ' M = G * (qs  qi)'  F32 = widget_text(F3, VALUE=v3, UVALUE='NONE', XSIZE=XS) ;*** /EDITABLE)  F33 = widget_label(F3, VALUE='[meters]', UVALUE='NONE');---------------------------------------------------------------------F4 = widget_base(A, /ROW, SPACE=ngap)  F41 = widget_label(F4, VALUE='Formula 4:', UVALUE='NONE')  v4  = ' IN = (P + SM),     if (P + SM) < Ks'  F42 = widget_text(F4, VALUE=v4, UVALUE='NONE', XSIZE=XS) ;*** /EDITABLE)  F43 = widget_label(F4, VALUE='[m/sec]', UVALUE='NONE');---------------------------------------------------------------------F5 = widget_base(A, /ROW, SPACE=ngap)  F51 = widget_label(F5, VALUE='Formula 5:', UVALUE='NONE')  v5  = ' IN = min(fc, (P + SM))'  F52 = widget_text(F5, VALUE=v5, UVALUE='NONE', XSIZE=XS) ;*** /EDITABLE)  F53 = widget_label(F5, VALUE='[m/sec]', UVALUE='NONE');---------------------------------------------------------------------FP = widget_label(A, VALUE=' ', UVALUE='NONE');------------------;Align the widgets;------------------Align_Text_Boxes, [F11, F21]Align_Text_Boxes, [F12, F22]Align_Text_Boxes, [F13, F23];------------------;Bottom button bar;------------------CW_Button_Bar, MB, /OK, /HELP  ;*** , /CANCEL;------------------------------------;Realize widgets and wait for events ;------------------------------------Realize_TLB, MB, state, 'GUI_Green_Ampt1_Formulas', $             XOFF=480, TW=[F12, F22]END;  GUI_Green_Ampt1_Formulas;*****************************************************************pro GUI_Smith_Parlange_Formulas_event, event;-----------;Error trap;-----------CATCH, statusTrace_Error, status, event, OKif NOT(OK) then RETURNGet_Event_Uvalue, event, uvalue, statecase (uvalue) of;*********'OK' : $;*********Close_Dialog, event.top ;***********'HELP' : $;***********Show_HTML_Help, 'infil_Smith-Parlange_formulas.htm';************'CANCEL' : $;************Close_Dialog, event.topELSE : dum=0endcaseif (uvalue ne 'CANCEL') AND $   (uvalue ne 'OK') then $    widget_control, event.top, set_uvalue=state END;  GUI_Smith_Parlange_Formulas_event;*****************************************************************pro GUI_Smith_Parlange_Formulas, leader;-----------;Error trap;-----------No_Catch, statusCheck_Error_Status, status, OKif NOT(OK) then RETURNif (n_elements(leader) eq 0) then leader=0L ;------------------------------------;Structure to store selected options;------------------------------------state = {leader_ID:leader}ngap = 6fsize = 20types = Model_Input_Types()XS = 44;-----------------;Main base widget;-----------------Create_TLB, MB, TITLE='Infiltration Formulas: Smith-Parlange Method', $            /COLUMN, LEADER=leader   ;***, /MODALA = widget_base(MB, /COLUMN, /FRAME);------------------;Show the formulas;------------------F1 = widget_base(A, /ROW, SPACE=ngap)  
  F11 = widget_label(F1, VALUE='Formula 1:', UVALUE='NONE')  v1  = ' fc = Ks + gamma * dK / {EXP[(gamma * F / M] ***** 1}'  F12 = widget_text(F1, VALUE=v1, UVALUE='NONE', XSIZE=XS) ;***, /EDITABLE)  F13 = widget_label(F1, VALUE='[m/sec]', UVALUE='NONE');---------------------------------------------------------------------F2 = widget_base(A, /ROW, SPACE=ngap)  F21 = widget_label(F2, VALUE='Formula 2:', UVALUE='NONE')  v2  = ' dK = (Ks  Ki)'  F22 = widget_text(F2, VALUE=v2, UVALUE='NONE', XSIZE=XS) ;*** /EDITABLE)  F23 = widget_label(F2, VALUE='[m/sec]', UVALUE='NONE');---------------------------------------------------------------------F3 = widget_base(A, /ROW, SPACE=ngap)  F31 = widget_label(F3, VALUE='Formula 3:', UVALUE='NONE')  v3  = ' M = G * (qs  qi)'  F32 = widget_text(F3, VALUE=v3, UVALUE='NONE', XSIZE=XS) ;*** /EDITABLE)  F33 = widget_label(F3, VALUE='[meters]', UVALUE='NONE');---------------------------------------------------------------------F4 = widget_base(A, /ROW, SPACE=ngap)  F41 = widget_label(F4, VALUE='Formula 4:', UVALUE='NONE')  v4  = ' IN = (P + SM),     if (P + SM) < Ks'  F42 = widget_text(F4, VALUE=v4, UVALUE='NONE', XSIZE=XS) ;*** /EDITABLE)  F43 = widget_label(F4, VALUE='[m/sec]', UVALUE='NONE');---------------------------------------------------------------------F5 = widget_base(A, /ROW, SPACE=ngap)  F51 = widget_label(F5, VALUE='Formula 5:', UVALUE='NONE')  v5  = ' IN = min(fc, (P + SM))'  F52 = widget_text(F5, VALUE=v5, UVALUE='NONE', XSIZE=XS) ;*** /EDITABLE)  F53 = widget_label(F5, VALUE='[m/sec]', UVALUE='NONE');---------------------------------------------------------------------FP = widget_label(A, VALUE=' ', UVALUE='NONE');------------------;Align the widgets;------------------Align_Text_Boxes, [F11, F21, F31, F41, F51]Align_Text_Boxes, [F12, F22, F32, F42, F52]Align_Text_Boxes, [F13, F23, F33, F43, F53];------------------;Bottom button bar;------------------CW_Button_Bar, MB, /OK, /HELP  ;*** , /CANCEL;------------------------------------;Realize widgets and wait for events ;------------------------------------Realize_TLB, MB, state, 'GUI_Smith_Parlange_Formulas', $             XOFF=480 ;**** , TW=[F12, F22]END;  GUI_Smith_Parlange_Formulas;*****************************************************************pro GUI_Richards_Eqn_Formulas_event, event;-----------;Error trap;-----------CATCH, statusTrace_Error, status, event, OKif NOT(OK) then RETURNGet_Event_Uvalue, event, uvalue, statecase (uvalue) of;*********'OK' : $;*********Close_Dialog, event.top ;***********'HELP' : $;***********Show_HTML_Help, 'infil_Richards_formulas.htm';************'CANCEL' : $;************Close_Dialog, event.topELSE : dum=0endcaseif (uvalue ne 'CANCEL') AND $   (uvalue ne 'OK') then $    widget_control, event.top, set_uvalue=state END;  GUI_Richards_Eqn_Formulas_event;*****************************************************************pro GUI_Richards_Eqn_Formulas, leader;-----------;Error trap;-----------No_Catch, statusCheck_Error_Status, status, OKif NOT(OK) then RETURNif (n_elements(leader) eq 0) then leader=0L ;------------------------------------;Structure to store selected options;------------------------------------state = {leader_ID:leader}ngap = 6fsize = 20types = Model_Input_Types()XS = 44;-----------------;Main base widget;-----------------Create_TLB, MB, /COLUMN, LEADER=leader, $            TITLE='Infiltration Formulas: Richards Eqn. Method'A = widget_base(MB, /COLUMN, /FRAME);------------------;Show the formulas;------------------F1 = widget_base(A, /ROW, SPACE=ngap)  F11 = widget_label(F1, VALUE='Formula 1:', UVALUE='NONE')  v1  = ' theta_(n+1) = theta_n + (dv/dz) * dt'  F12 = widget_text(F1, VALUE=v1, UVALUE='NONE', XSIZE=XS) ;***, /EDITABLE)  F13 = widget_label(F1, VALUE='[unitless]', UVALUE='NONE');---------------------------------------------------------------------F2 = widget_base(A, /ROW, SPACE=ngap)  F21 = widget_label(F2, VALUE='Formula 2:', UVALUE='NONE')  v2  = ' Se = (theta - theta_r) / (theta_s - theta_r)'  F22 = widget_text(F2, VALUE=v2, UVALUE='NONE', XSIZE=XS) ;*** /EDITABLE)  F23 = widget_label(F2, VALUE='[unitless]', UVALUE='NONE');---------------------------------------------------------------------F3 = widget_base(A, /ROW, SPACE=ngap)  F31 = widget_label(F3, VALUE='Formula 3:', UVALUE='NONE')  v3  = ' psi = psi_B * [Se^(-c/lambda) - 1]^(1/c) - psi_A'  F32 = widget_text(F3, VALUE=v3, UVALUE='NONE', XSIZE=XS) ;*** /EDITABLE)  F33 = widget_label(F3, VALUE='[meters]', UVALUE='NONE');---------------------------------------------------------------------F4 = widget_base(A, /ROW, SPACE=ngap)  F41 = widget_label(F4, VALUE='Formula 4:', UVALUE='NONE')  v4  = ' psi_min = -320   (used to compute theta_min)'  F42 = widget_text(F4, VALUE=v4, UVALUE='NONE', XSIZE=XS) ;*** /EDITABLE)  F43 = widget_label(F4, VALUE='[meters]', UVALUE='NONE');---------------------------------------------------------------------F5 = widget_base(A, /ROW, SPACE=ngap)  F51 = widget_label(F5, VALUE='Formula 5:', UVALUE='NONE')  v5  = ' K = Ks * {1 + [(psi + psi_A)/psi_B]^c}^(-eta/c)'  F52 = widget_text(F5, VALUE=v5, UVALUE='NONE', XSIZE=XS) ;*** /EDITABLE)  F53 = widget_label(F5, VALUE='[m/sec]', UVALUE='NONE');---------------------------------------------------------------------F6 = widget_base(A, /ROW, SPACE=ngap)  F61 = widget_label(F6, VALUE='Formula 6:', UVALUE='NONE')  v6  = ' v = Ks * (1 - dpsi/dz)'  F62 = widget_text(F6, VALUE=v6, UVALUE='NONE', XSIZE=XS) ;*** /EDITABLE)  F63 = widget_label(F6, VALUE='[m/sec]', UVALUE='NONE');---------------------------------------------------------------------FP = widget_label(A, VALUE=' ', UVALUE='NONE');------------------;Align the widgets;------------------Align_Text_Boxes, [F11, F21, F31, F41, F51, F61]Align_Text_Boxes, [F12, F22, F32, F42, F52, F62]Align_Text_Boxes, [F13, F23, F33, F43, F53, F63];------------------;Bottom button bar;------------------CW_Button_Bar, MB, /OK, /HELP  ;*** , /CANCEL;------------------------------------;Realize widgets and wait for events ;------------------------------------Realize_TLB, MB, state, 'GUI_Richards_Eqn_Formulas', $             XOFF=480, TW=[F12, F22]END;  GUI_Richards_Eqn_Formulas;*****************************************************************